<!DOCTYPE html>
<html>
  <head>
    <title>Contour Plot with P5.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
      canvas {
        border: 1px solid #ccc;
      }
      #container {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <h2>Contour Plot Example</h2>
      <div id="canvas-container"></div>
    </div>

    <script>
      function createContourPlot(
        width,
        height,
        xValues,
        yValues,
        zValues,
        levels
      ) {
        let sketch = function (p) {
          const margin = 40;
          const plotWidth = width - 2 * margin;
          const plotHeight = height - 2 * margin;

          // Helper function to map data coordinates to screen coordinates
          function mapToScreen(x, y) {
            const screenX = p.map(
              x,
              Math.min(...xValues),
              Math.max(...xValues),
              margin,
              width - margin
            );
            const screenY = p.map(
              y,
              Math.min(...yValues),
              Math.max(...yValues),
              height - margin,
              margin
            );
            return { x: screenX, y: screenY };
          }

          // Helper function to interpolate between two points
          function interpolate(x1, y1, v1, x2, y2, v2, level) {
            const t = (level - v1) / (v2 - v1);
            return {
              x: x1 + t * (x2 - x1),
              y: y1 + t * (y2 - y1),
            };
          }

          p.setup = function () {
            p.createCanvas(width, height);
            p.colorMode(p.HSB, 360, 100, 100, 1.0);
          };

          p.draw = function () {
            p.background(255);

            // Draw axes
            p.stroke(0);
            p.line(margin, height - margin, width - margin, height - margin); // x-axis
            p.line(margin, margin, margin, height - margin); // y-axis

            // Helper function to get nice tick values
            function getNiceTickValues(min, max, numTicks) {
              const range = max - min;
              const roughStep = range / numTicks;

              // Get a nice step value (1, 2, or 5 multiplied by a power of 10)
              const step = Math.pow(10, Math.floor(Math.log10(roughStep)));
              let niceStep;
              if (roughStep / step < 2) niceStep = step;
              else if (roughStep / step < 5) niceStep = step * 2;
              else niceStep = step * 5;

              // Get nice min and max values
              const niceMin = Math.floor(min / niceStep) * niceStep;
              const niceMax = Math.ceil(max / niceStep) * niceStep;

              // Generate tick values
              const ticks = [];
              for (let tick = niceMin; tick <= niceMax; tick += niceStep) {
                ticks.push(tick);
              }
              return ticks;
            }

            // X-axis ticks
            const xTicks = getNiceTickValues(
              Math.min(...xValues),
              Math.max(...xValues),
              4
            );
            xTicks.forEach((x) => {
              const screenX = mapToScreen(x, 0).x;

              // Draw tick
              p.stroke(0);
              p.line(screenX, height - margin, screenX, height - margin + 5);

              // Draw label
              p.noStroke();
              p.textAlign(p.CENTER, p.TOP);
              p.text(x, screenX, height - margin + 7);
            });

            // Y-axis ticks
            const yTicks = getNiceTickValues(
              Math.min(...yValues),
              Math.max(...yValues),
              4
            );
            yTicks.forEach((y) => {
              const screenY = mapToScreen(0, y).y;

              // Draw tick
              p.stroke(0);
              p.line(margin - 5, screenY, margin, screenY);

              // Draw label
              p.noStroke();
              p.textAlign(p.RIGHT, p.CENTER);
              p.text(y, margin - 7, screenY);
            });

            // Sort levels in ascending order
            const sortedLevels = [...levels].sort((a, b) => a - b);

            // Draw filled contour areas
            for (
              let levelIndex = 0;
              levelIndex < sortedLevels.length - 1;
              levelIndex++
            ) {
              const level = sortedLevels[levelIndex];
              const nextLevel = sortedLevels[levelIndex + 1];

              // Calculate color for this band
              const hue = p.map(levelIndex, 0, sortedLevels.length - 1, 0, 360);
              p.fill(hue, 100, 100, 1.0); // Fully saturated colors
              p.noStroke();

              // Draw rectangles for areas between current level and next level
              for (let i = 0; i < xValues.length - 1; i++) {
                for (let j = 0; j < yValues.length - 1; j++) {
                  const x1 = xValues[i];
                  const x2 = xValues[i + 1];
                  const y1 = yValues[j];
                  const y2 = yValues[j + 1];

                  const v = zValues[i][j];

                  if (v >= level && v < nextLevel) {
                    const screen1 = mapToScreen(x1, y1);
                    const screen2 = mapToScreen(x2, y2);
                    p.rect(
                      screen1.x,
                      screen1.y,
                      screen2.x - screen1.x,
                      screen2.y - screen1.y
                    );
                  }
                }
              }
            }

            // Draw contour lines
            sortedLevels.forEach((level) => {
              p.stroke(0);
              p.strokeWeight(0.5);
              p.noFill();

              // Iterate through the grid
              for (let i = 0; i < xValues.length - 1; i++) {
                for (let j = 0; j < yValues.length - 1; j++) {
                  const x1 = xValues[i];
                  const x2 = xValues[i + 1];
                  const y1 = yValues[j];
                  const y2 = yValues[j + 1];

                  const v11 = zValues[i][j];
                  const v12 = zValues[i][j + 1];
                  const v21 = zValues[i + 1][j];
                  const v22 = zValues[i + 1][j + 1];

                  // Marching squares algorithm
                  let points = [];

                  // Check each edge for intersections
                  if (
                    (v11 < level && v21 >= level) ||
                    (v11 >= level && v21 < level)
                  ) {
                    const point = interpolate(x1, y1, v11, x2, y1, v21, level);
                    points.push(mapToScreen(point.x, point.y));
                  }
                  if (
                    (v21 < level && v22 >= level) ||
                    (v21 >= level && v22 < level)
                  ) {
                    const point = interpolate(x2, y1, v21, x2, y2, v22, level);
                    points.push(mapToScreen(point.x, point.y));
                  }
                  if (
                    (v12 < level && v22 >= level) ||
                    (v12 >= level && v22 < level)
                  ) {
                    const point = interpolate(x1, y2, v12, x2, y2, v22, level);
                    points.push(mapToScreen(point.x, point.y));
                  }
                  if (
                    (v11 < level && v12 >= level) ||
                    (v11 >= level && v12 < level)
                  ) {
                    const point = interpolate(x1, y1, v11, x1, y2, v12, level);
                    points.push(mapToScreen(point.x, point.y));
                  }

                  // Draw lines between intersection points
                  if (points.length >= 2) {
                    p.beginShape();
                    points.forEach((point) => p.vertex(point.x, point.y));
                    p.endShape();
                  }
                }
              }
            });

            // Draw axes labels
            p.noStroke();
            p.fill(0);
            p.textAlign(p.CENTER, p.CENTER);
            p.text("X", width - margin + 20, height - margin);
            p.text("Y", margin - 20, margin - 20);
          };
        };

        new p5(sketch, "canvas-container");
      }

      // Example usage
      const width = 1000;
      const height = 1000;

      // Create sample data
      const xValues = Array.from({ length: 50 }, (_, i) => i * 0.2 - 5);
      const yValues = Array.from({ length: 50 }, (_, i) => i * 0.2 - 5);
      const zValues = xValues.map((x) =>
        yValues.map(
          (y) => Math.sin(Math.sqrt(x * x + y * y)) / Math.sqrt(x * x + y * y)
        )
      );
      const levels = [-0.2, -0.1, 0, 0.1, 0.2];

      // Create the contour plot
      createContourPlot(width, height, xValues, yValues, zValues, levels);
    </script>
  </body>
</html>
