<!DOCTYPE html>
<html>
  <head>
    <title>Box Plot Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        font-family: Arial, sans-serif;
        margin: 20px;
      }
    </style>
  </head>
  <body>
    <h1>Box Plot Visualization</h1>
    <script>
      // Sample data - multiple arrays of values, including outliers
      const testData = [
        [2, 4, 6, 7, 8, 9, 10, 11, 12, 15], // Group 1
        [5, 7, 8, 8, 9, 9, 10, 11, 13, 15, 16, 17, 35, 38], // Group 2 with outliers
        [1, 3, 4, 5, 6, 7, 8, 9, 10, 12, 15, 18], // Group 3
      ];

      function setup() {
        createCanvas(800, 400);
        background(255);
        drawBoxPlot(width - 100, height - 100, testData);
      }

      function getNiceScale(min, max) {
        const range = max - min;
        const magnitude = Math.pow(10, Math.floor(Math.log10(range)));
        const scaledRange = range / magnitude;

        let niceTick;
        if (scaledRange < 1.5) niceTick = 0.1;
        else if (scaledRange < 3) niceTick = 0.2;
        else if (scaledRange < 7) niceTick = 0.5;
        else niceTick = 1;

        niceTick *= magnitude;

        const niceMin = Math.floor(min / niceTick) * niceTick;
        const niceMax = Math.ceil(max / niceTick) * niceTick;

        return { min: niceMin, max: niceMax, tick: niceTick };
      }

      function drawBoxPlot(chartWidth, chartHeight, data) {
        const margin = { top: 40, right: 40, bottom: 40, left: 60 };
        const plotWidth = chartWidth - margin.left - margin.right;
        const plotHeight = chartHeight - margin.top - margin.bottom;

        // Find global min and max for scaling
        let allValues = data.flat();
        let minVal = Math.min(...allValues);
        let maxVal = Math.max(...allValues);

        // Use nice scale for the y-axis
        const {
          min: niceMin,
          max: niceMax,
          tick: niceTick,
        } = getNiceScale(minVal, maxVal);
        minVal = niceMin;
        maxVal = niceMax;

        // Drawing settings
        const boxWidth = 50;
        const groupSpacing = plotWidth / (data.length + 1);

        // Move to the plotting area
        push();
        translate(margin.left, margin.top);

        // Draw axes
        stroke(0);
        strokeWeight(1);
        line(0, plotHeight, plotWidth, plotHeight); // x-axis
        line(0, 0, 0, plotHeight); // y-axis

        // Draw y-axis labels
        noStroke();
        fill(0);
        textAlign(RIGHT, CENTER);
        const numTicks = Math.round((maxVal - minVal) / niceTick);
        for (let i = 0; i <= numTicks; i++) {
          const value = minVal + i * niceTick;
          const y =
            plotHeight - ((value - minVal) / (maxVal - minVal)) * plotHeight;
          text(value.toFixed(1), -10, y);
          stroke(200);
          line(0, y, plotWidth, y);
        }

        // Draw box plots
        stroke(0);
        data.forEach((group, index) => {
          const groupX = (index + 1) * groupSpacing;

          // Calculate statistics
          group.sort((a, b) => a - b);
          const q1 = calculateQuantile(group, 0.25);
          const median = calculateQuantile(group, 0.5);
          const q3 = calculateQuantile(group, 0.75);
          const iqr = q3 - q1;
          const lowerFence = q1 - 1.5 * iqr;
          const upperFence = q3 + 1.5 * iqr;

          // Find whisker points and outliers
          const outliers = [];
          let lowerWhisker = null;
          let upperWhisker = null;

          group.forEach((value) => {
            if (value < lowerFence || value > upperFence) {
              outliers.push(value);
            } else {
              if (lowerWhisker === null || value < lowerWhisker)
                lowerWhisker = value;
              if (upperWhisker === null || value > upperWhisker)
                upperWhisker = value;
            }
          });

          // Scale values to plot height
          const scaleY = (val) => {
            return (
              plotHeight - ((val - minVal) / (maxVal - minVal)) * plotHeight
            );
          };

          // Draw box
          stroke(0);
          strokeWeight(1);
          fill(255);
          rect(
            groupX - boxWidth / 2,
            scaleY(q3),
            boxWidth,
            scaleY(q1) - scaleY(q3)
          );

          // Draw median line
          stroke(0);
          strokeWeight(2);
          line(
            groupX - boxWidth / 2,
            scaleY(median),
            groupX + boxWidth / 2,
            scaleY(median)
          );

          // Draw whiskers
          strokeWeight(1);
          if (upperWhisker !== null) {
            line(groupX, scaleY(q3), groupX, scaleY(upperWhisker)); // Upper whisker
            line(
              groupX - boxWidth / 4,
              scaleY(upperWhisker),
              groupX + boxWidth / 4,
              scaleY(upperWhisker)
            ); // Upper whisker cap
          }
          if (lowerWhisker !== null) {
            line(groupX, scaleY(q1), groupX, scaleY(lowerWhisker)); // Lower whisker
            line(
              groupX - boxWidth / 4,
              scaleY(lowerWhisker),
              groupX + boxWidth / 4,
              scaleY(lowerWhisker)
            ); // Lower whisker cap
          }

          // Draw outliers
          stroke(0);
          strokeWeight(1);
          fill(0);
          outliers.forEach((value) => {
            circle(groupX, scaleY(value), 5);
          });

          // Draw group labels
          noStroke();
          fill(0);
          textAlign(CENTER, TOP);
          text(`Group ${index + 1}`, groupX, plotHeight + 10);
        });

        pop();
      }

      function calculateQuantile(sortedArr, q) {
        const pos = (sortedArr.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;

        if (sortedArr[base + 1] !== undefined) {
          return (
            sortedArr[base] + rest * (sortedArr[base + 1] - sortedArr[base])
          );
        } else {
          return sortedArr[base];
        }
      }
    </script>
  </body>
</html>
