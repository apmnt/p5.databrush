<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>P5.js Histogram</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Josefin+Sans:ital,wght@0,100..700;1,100..700&display=swap"
      rel="stylesheet"
    />
    <script src="p5.js"></script>
    <script src="spectral.min.js"></script>
    <script src="p5.brush.js"></script>
    <script
      defer
      src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"
    ></script>
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        font-family: "IBM Plex Serif", sans-serif;
        font-size: 16px;
        margin: 0;
        padding: 0;
        display: flex;
        align-items: flex-start;
        justify-content: center;
        min-height: 100vh;
        overflow-x: hidden;
        background-color: #fffefb;
        position: relative;
      }

      .data-input {
        margin: 10px 0;
        font-family: monospace;
        width: 100%;
        height: 200px;
        background-color: #00000000;
      }

      input {
        width: 128px;
      }

      input[type="number"],
      input[type="text"] {
        margin-left: 10px;
        float: right;
        border-radius: 0;
        border: none;
        background-color: #ffffff00;
      }

      input[type="color"] {
        height: 24px;
        border-radius: 0;
        padding: 0;
        border: none;
        background: none;
        float: right;
      }

      .controls {
        width: 400px;
        flex-shrink: 0;
        position: relative;
        min-height: 100vh;
        padding-left: 20px;
        padding-right: 10px;
        overflow: hidden;
        z-index: 999;
      }

      .collapsible-section {
        border-top: 1px solid #000000;
      }

      .collapsible-header {
        padding-top: 10px;
        padding-bottom: 10px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        user-select: none;
        font-weight: bold;
      }

      .collapsible-content {
        border-top: none;
        padding-bottom: 15px;
        padding-top: 10px;
      }

      .collapsible-content label {
        display: block;
        margin-bottom: 8px;
      }

      .arrow {
        transition: transform 0.3s;
      }

      .arrow.open {
        transform: rotate(90deg);
      }

      #chartContainer {
        flex: 1;
        flex-direction: column;
        max-width: fit-content;
        height: 100vh;
        border: 1px solid #ccc;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        margin: 0;
        padding: 0;
        position: sticky;
        top: 0;
        background-color: #f9f9f9;
      }

      /* Loading placeholder - only show when canvas doesn't exist */
      #chartContainer:empty::before {
        content: "Loading...";
        display: block;
        width: 1000px;
        aspect-ratio: 1;
        max-width: min(100%, 95vh);
        max-height: 95vh;
        font-family: "IBM Plex Serif", sans-serif;
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: fadeOut 0.5s ease-out forwards;
      }

      /* Fade out animation for placeholder */
      @keyframes fadeOut {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }

      /* Fade in animation for canvas */
      @keyframes fadeIn {
        0% {
          opacity: 0;
        }
        100% {
          opacity: 1;
        }
      }

      #chartContainer canvas {
        max-width: 100%;
        max-height: 95vh;
        padding: 0;
        width: auto !important;
        height: auto !important;
        display: block;
        object-fit: contain;
        animation: fadeIn 0.6s ease-out;
      }

      /* Responsive layout for smaller screens */
      @media (max-width: 800px) {
        body {
          flex-direction: column;
          align-items: stretch;
        }

        #chartContainer {
          margin: 0;
          position: sticky;
          top: 0;
          height: auto;
          max-height: 70vh;
          border: none;
          z-index: 100;
        }

        /* Adjust loading placeholder for mobile */
        #chartContainer:empty::before {
          max-width: 100vw;
          max-height: 100vh;
          background-color: #fffceb;
          animation: fadeOut 0.5s ease-out;
        }

        #chartContainer canvas {
          max-height: 100vh;
        }

        .controls {
          margin: 0;
          width: 100%;
          max-width: 800px;
          order: 2;
          margin-bottom: 20px;
          padding-left: 10px;
          padding-right: 10px;
          min-height: auto;
          overflow: visible;
        }
      }

      input,
      textarea,
      .dropdown {
        font-size: 16px;
      }

      .footer {
        margin-top: 50px;
        padding: 10px 0px 10px 0px;
        font-size: 12px;
        color: #666;
        text-align: left;
      }

      .footer a {
        color: #666;
      }

      button {
        font-family: "IBM Plex Serif", sans-serif;
        background-color: #00000000;
        color: rgb(0, 0, 0);
        border: 2px solid #000000;
        padding: 10px 20px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        margin-top: 10px;
        cursor: pointer;
        border-radius: 5px;
      }

      .button-message {
        font-size: 12px;
        margin-left: 10px;
      }

      .dropdown {
        font-family: "IBM Plex Serif", sans-serif;
        width: 128px;
        margin-left: 10px;
        padding-left: 10px;
        float: right;
        height: 22px;
        border: 0;
        background-color: #ffffff00;
        color: #000;
        padding: 0;
      }

      /* Mobile tab navigation */
      .mobile-tabs {
        display: none;
      }

      .mobile-content-area {
        display: none;
      }

      .mobile-section-title {
        display: none;
      }

      @media (max-width: 800px) {
        body {
          padding-bottom: 20px;
          justify-content: flex-start;
        }

        .controls {
          padding-bottom: 20px;
          overflow-y: visible;
          min-height: auto;
          position: relative;
        }

        .controls::before {
          content: "";
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ffffff49;
          backdrop-filter: blur(100px);
          -webkit-backdrop-filter: blur(100px);
          -webkit-mask-image: linear-gradient(
            to bottom,
            rgba(0, 0, 0, 0) 0px,
            rgba(0, 0, 0, 1) 30px
          );
          mask-image: linear-gradient(
            to bottom,
            rgba(0, 0, 0, 0) 0px,
            rgba(0, 0, 0, 1) 30px
          );
          z-index: -1;
          pointer-events: none;
        }

        .controls > h1,
        .controls > p {
          display: none;
        }

        .mobile-content-area {
          display: block;
          min-height: auto;
        }

        .mobile-section-title,
        .mobile-databrush-title {
          display: none;
        }

        .mobile-tabs {
          display: block;
          position: relative;
          margin-left: -20px;
          margin-right: -10px;
          padding-right: 10px;
          padding-bottom: 20px;
          height: auto;
          overflow-x: auto;
          overflow-y: hidden;
          white-space: nowrap;
          -webkit-overflow-scrolling: touch;
          scrollbar-width: none; /* Firefox */
          -ms-overflow-style: none; /* Edge */
          scroll-snap-type: x proximity;
          user-select: none;
          -webkit-user-select: none;
          -moz-user-select: none;
          -ms-user-select: none;
        }

        .mobile-tabs::-webkit-scrollbar {
          display: none; /* Chrome, Safari, Opera */
        }

        .mobile-tab {
          display: inline-block;
          padding: 8px 0px;
          margin-right: 20px;
          cursor: pointer;
          user-select: none;
          font-family: "IBM Plex Serif", sans-serif;
          font-size: 1.5em;
          font-weight: normal;
          color: #999;
          transition: color 0.2s;
          scroll-snap-align: start;
          position: relative;
          mix-blend-mode: difference;
          -webkit-tap-highlight-color: transparent;
        }

        .mobile-tab::after {
          content: attr(data-text);
          content: attr(data-text) / "";
          height: 0;
          visibility: hidden;
          overflow: hidden;
          user-select: none;
          pointer-events: none;
          font-weight: bold;
          display: block;
        }

        .mobile-tab:first-child {
          padding-left: 20px;
        }

        .mobile-tab.active {
          color: #000;
          font-weight: bold;
        }

        .collapsible-section {
          border-top: none;
        }

        .collapsible-header {
          display: none;
        }

        .collapsible-content {
          display: none;
          border-top: none;
          padding-top: 0;
        }

        .collapsible-content.mobile-active {
          display: block !important;
        }

        .about-text {
          margin-top: 0;
        }
      }
    </style>
  </head>
  <body x-data="chartData()">
    <div id="chartContainer"></div>
    <div class="controls">
      <div class="mobile-tabs" x-ref="mobileTabsContainer">
        <div
          class="mobile-tab"
          :class="{ active: activeTab === 'about' }"
          @click="setActiveTab('about')"
          x-ref="tab_about"
          data-text="*p5.databrush"
        >
          *p5.databrush
        </div>
        <div
          class="mobile-tab"
          :class="{ active: activeTab === 'chartOptions' }"
          @click="setActiveTab('chartOptions')"
          x-ref="tab_chartOptions"
          data-text="chart"
        >
          chart
        </div>
        <div
          class="mobile-tab"
          :class="{ active: activeTab === 'style' }"
          @click="setActiveTab('style')"
          x-ref="tab_style"
          data-text="style"
        >
          style
        </div>
        <div
          class="mobile-tab"
          :class="{ active: activeTab === 'palette' }"
          @click="setActiveTab('palette')"
          x-ref="tab_palette"
          data-text="palette"
        >
          palette
        </div>
        <div
          class="mobile-tab"
          :class="{ active: activeTab === 'fill' }"
          @click="setActiveTab('fill')"
          x-ref="tab_fill"
          data-text="fill"
        >
          fill
        </div>
        <div
          class="mobile-tab"
          :class="{ active: activeTab === 'typography' }"
          @click="setActiveTab('typography')"
          x-ref="tab_typography"
          data-text="typography"
        >
          typography
        </div>
        <div
          class="mobile-tab"
          :class="{ active: activeTab === 'dimensions' }"
          @click="setActiveTab('dimensions')"
          x-ref="tab_dimensions"
          data-text="canvas"
        >
          canvas
        </div>
      </div>
      <!-- Mobile content area -->
      <div class="mobile-content-area">
        <!-- About section (mobile only) -->
        <div
          class="collapsible-content"
          :class="{ 'mobile-active': activeTab === 'about' }"
          x-show="activeTab === 'about'"
        >
          <p class="about-text">
            Visualize your data on a watercolor canvas. Choose from histograms,
            scatter plots, box plots, and line plots. Customize the settings and
            use your own data, or try randomized plots with sample datasets and
            palettes.
          </p>
          <button @click="randomizeAll()">Randomize everything</button>
          <br />
          <button @click="generateRandomData()">Generate random data</button>
          <br />
          <button @click="updateChart()" x-text="'Redraw chart'"></button>
          <span class="button-message" x-show="!isValidData"
            >Please enter valid JSON array</span
          >
          <br />
          <button @click="exportConfig()">Export config</button>
          <span
            class="button-message"
            x-show="exportStatus"
            x-text="exportStatus"
          ></span>
          <br />
          <button @click="copyConfigToClipboard()">
            Copy config to clipboard
          </button>
          <span
            class="button-message"
            x-show="copyConfigStatus"
            x-text="copyConfigStatus"
          ></span>
          <br />
          <button @click="loadConfigFromClipboard()">
            Load config from clipboard
          </button>
          <span
            class="button-message"
            x-show="loadClipboardStatus"
            x-text="loadClipboardStatus"
          ></span>
          <br />
          <button @click="$refs.configFileInput.click()">Load config</button>
          <input
            type="file"
            x-ref="configFileInput"
            @change="loadConfig($event)"
            accept=".json"
            style="display: none"
          />
          <span
            class="button-message"
            x-show="loadStatus"
            x-text="loadStatus"
          ></span>
        </div>
      </div>

      <!-- Chart Section -->
      <div class="collapsible-section">
        <div class="collapsible-header" @click="toggleSection('chartOptions')">
          <span>Chart</span>
          <span class="arrow" :class="{ open: openSections.chartOptions }"
            >►</span
          >
        </div>
        <div
          class="collapsible-content mobile-content-area"
          :class="{ 'mobile-active': activeTab === 'chartOptions' }"
          x-show="!isMobile() ? openSections.chartOptions : activeTab === 'chartOptions'"
        >
          <label>
            Chart Type:
            <select
              class="dropdown"
              x-model="chartType"
              @change="onChartTypeChange()"
            >
              <option value="histogram">Histogram</option>
              <option value="scatter">Scatter Plot</option>
              <option value="boxplot">Box Plot</option>
              <option value="line">Line Plot</option>
              <option value="barplot">Bar Plot</option>
            </select>
          </label>
          <div x-show="chartType === 'histogram'">
            <label
              >Number of Bins:
              <input type="number" x-model="numBins" @change="updateChart()"
            /></label>
          </div>
          <div x-show="chartType === 'line'">
            <label>
              <input
                type="checkbox"
                x-model="showDots"
                @change="updateChart()"
                style="width: auto; margin-left: 0; float: none"
              />
              Show Dots
            </label>
          </div>
        </div>
      </div>

      <!-- Style Section -->
      <div class="collapsible-section">
        <div class="collapsible-header" @click="toggleSection('style')">
          <span>Style</span>
          <span class="arrow" :class="{ open: openSections.style }">►</span>
        </div>
        <div
          class="collapsible-content mobile-content-area"
          :class="{ 'mobile-active': activeTab === 'style' }"
          x-show="!isMobile() ? openSections.style : activeTab === 'style'"
        >
          <label>
            Style Preset:
            <select
              class="dropdown"
              x-model="stylePreset"
              @change="onStylePresetChange()"
            >
              <template x-for="preset in stylePresetNames" :key="preset">
                <option
                  :value="preset"
                  x-text="preset.replace(/_/g, ' ')"
                ></option>
              </template>
              <option value="custom">Custom</option>
            </select>
          </label>
          <label
            >Background Color:
            <input
              type="color"
              x-model="backgroundColor"
              @change="stylePreset = 'custom'; updateChart()"
          /></label>
          <label
            >Axis Label Color:
            <input
              type="color"
              x-model="axisLabelColor"
              @change="stylePreset = 'custom'; updateChart()"
          /></label>
          <label>
            Brush Type:
            <select
              class="dropdown"
              x-model="brushType"
              @change="stylePreset = 'custom'; updateChart()"
            >
              <option value="pen">Pen</option>
              <option value="rotring">Rotring</option>
              <option value="2B">2B Pencil</option>
              <option value="HB">HB Pencil</option>
              <option value="2H">2H Pencil</option>
              <option value="cpencil">Color Pencil</option>
              <option value="charcoal">Charcoal</option>
              <option value="hatch_brush">Hatch Brush</option>
              <option value="marker">Marker</option>
              <option value="marker2">Marker 2</option>
            </select>
          </label>
          <label
            >Line Color:
            <input
              type="color"
              x-model="lineColor"
              @change="stylePreset = 'custom'; updateChart()"
          /></label>
          <label
            >Line Width:
            <input
              type="number"
              x-model="lineWidth"
              min="0.5"
              max="10"
              step="0.5"
              @change="stylePreset = 'custom'; updateChart()"
          /></label>
          <label>
            Grid Brush Type:
            <select
              class="dropdown"
              x-model="gridBrushType"
              @change="stylePreset = 'custom'; updateChart()"
            >
              <option value="pen">Pen</option>
              <option value="rotring">Rotring</option>
              <option value="2B">2B Pencil</option>
              <option value="HB">HB Pencil</option>
              <option value="2H">2H Pencil</option>
              <option value="cpencil">Color Pencil</option>
              <option value="charcoal">Charcoal</option>
              <option value="hatch_brush">Hatch Brush</option>
              <option value="marker">Marker</option>
              <option value="marker2">Marker 2</option>
            </select>
          </label>
          <label
            >Grid Line Color:
            <input
              type="color"
              x-model="gridLineColor"
              @change="stylePreset = 'custom'; updateChart()"
          /></label>
          <label
            >Grid Line Width:
            <input
              type="number"
              x-model="gridLineWidth"
              min="0.5"
              max="10"
              step="0.5"
              @change="stylePreset = 'custom'; updateChart()"
          /></label>
        </div>
      </div>

      <!-- Palette & Colors Section -->
      <div class="collapsible-section">
        <div class="collapsible-header" @click="toggleSection('palette')">
          <span>Palette & Colors</span>
          <span class="arrow" :class="{ open: openSections.palette }">►</span>
        </div>
        <div
          class="collapsible-content mobile-content-area"
          :class="{ 'mobile-active': activeTab === 'palette' }"
          x-show="!isMobile() ? openSections.palette : activeTab === 'palette'"
        >
          <label>
            Palette Preset:
            <select
              class="dropdown"
              x-model="palettePreset"
              @change="onPalettePresetChange()"
            >
              <template
                x-for="presetName in palettePresetNames"
                :key="presetName"
              >
                <option :value="presetName" x-text="presetName"></option>
              </template>
              <option value="custom">Custom</option>
            </select>
          </label>
          <label>
            <input
              type="checkbox"
              x-model="randomColors"
              @change="updateChart()"
              style="width: auto; margin-left: 0; float: none"
            />
            Random Colors from Palette
          </label>
          <label>
            <input
              type="checkbox"
              x-model="shuffleColors"
              @change="onShuffleColorsChange()"
              style="width: auto; margin-left: 0; float: none"
            />
            Shuffle Color Order
          </label>
          <div x-show="!randomColors">
            <!-- Histogram: 1 color -->
            <template x-if="chartType === 'histogram'">
              <div>
                <label
                  >Color 1:
                  <input
                    type="color"
                    x-model="color1"
                    @input="handleColorInput()"
                    @change="onColorChange()"
                /></label>
              </div>
            </template>

            <!-- Scatter plot: dynamic based on data -->
            <template x-if="chartType === 'scatter'">
              <div>
                <template x-for="i in getScatterColorCount()" :key="i">
                  <label>
                    <span
                      x-text="'Color ' + i + ':'"
                      style="display: inline-block; width: 60px"
                    ></span>
                    <input
                      type="color"
                      :value="getColorValue(i)"
                      @input="setColorValue(i, $event.target.value)"
                      @change="onColorChange()"
                    />
                  </label>
                </template>
              </div>
            </template>

            <!-- Box plot: dynamic based on data -->
            <template x-if="chartType === 'boxplot'">
              <div>
                <template x-for="i in getBoxPlotColorCount()" :key="i">
                  <label>
                    <span
                      x-text="'Color ' + i + ':'"
                      style="display: inline-block; width: 60px"
                    ></span>
                    <input
                      type="color"
                      :value="getColorValue(i)"
                      @input="setColorValue(i, $event.target.value)"
                      @change="onColorChange()"
                    />
                  </label>
                </template>
              </div>
            </template>

            <!-- Line plot: dynamic based on data -->
            <template x-if="chartType === 'line'">
              <div>
                <template x-for="i in getLineColorCount()" :key="i">
                  <label>
                    <span
                      x-text="'Color ' + i + ':'"
                      style="display: inline-block; width: 60px"
                    ></span>
                    <input
                      type="color"
                      :value="getColorValue(i)"
                      @input="setColorValue(i, $event.target.value)"
                      @change="onColorChange()"
                    />
                  </label>
                </template>
              </div>
            </template>

            <!-- Bar plot: dynamic based on data -->
            <template x-if="chartType === 'barplot'">
              <div>
                <template x-for="i in getBarPlotColorCount()" :key="i">
                  <label>
                    <span
                      x-text="'Color ' + i + ':'"
                      style="display: inline-block; width: 60px"
                    ></span>
                    <input
                      type="color"
                      :value="getColorValue(i)"
                      @input="setColorValue(i, $event.target.value)"
                      @change="onColorChange()"
                    />
                  </label>
                </template>
              </div>
            </template>
          </div>
        </div>
      </div>

      <!-- Fill Section -->
      <div class="collapsible-section">
        <div class="collapsible-header" @click="toggleSection('fill')">
          <span>Fill</span>
          <span class="arrow" :class="{ open: openSections.fill }">►</span>
        </div>
        <div
          class="collapsible-content mobile-content-area"
          :class="{ 'mobile-active': activeTab === 'fill' }"
          x-show="!isMobile() ? openSections.fill : activeTab === 'fill'"
        >
          <label>
            Fill Type:
            <select
              class="dropdown"
              x-model="fillType"
              @change="useHatching = (fillType === 'hatch'); updateChart()"
            >
              <option value="watercolor">Watercolor</option>
              <option value="hatch">Hatch</option>
              <option value="none">No Fill</option>
            </select>
          </label>

          <!-- Watercolor -->
          <div x-show="fillType === 'watercolor'">
            <label
              >Bleed Min:
              <input
                type="number"
                x-model="bleedMin"
                min="0"
                max="1"
                step="0.01"
                @change="updateChart()"
            /></label>
            <label
              >Bleed Max:
              <input
                type="number"
                x-model="bleedMax"
                min="0"
                max="1"
                step="0.01"
                @change="updateChart()"
            /></label>
          </div>

          <!-- Hatching -->
          <div x-show="fillType === 'hatch'">
            <label
              >Hatch Distance:
              <input
                type="number"
                x-model="hatchDistance"
                min="1"
                max="20"
                step="1"
                @change="updateChart()"
            /></label>
            <label
              >Hatch Angle:
              <input
                type="number"
                x-model="hatchAngle"
                min="0"
                max="180"
                step="5"
                @change="updateChart()"
            /></label>
            <label
              >Hatch Randomness:
              <input
                type="number"
                x-model="hatchRand"
                min="0"
                max="1"
                step="0.05"
                @change="updateChart()"
            /></label>
            <label
              >Hatch Gradient:
              <input
                type="number"
                x-model="hatchGradient"
                min="0"
                max="1"
                step="0.05"
                @change="updateChart()"
            /></label>
            <label>
              <input
                type="checkbox"
                x-model="hatchContinuous"
                @change="updateChart()"
                style="width: auto; margin-left: 0; float: none"
              />
              Continuous Hatching
            </label>
            <label>
              Hatch Brush Type:
              <select
                class="dropdown"
                x-model="hatchBrushType"
                @change="updateChart()"
              >
                <option value="pen">Pen</option>
                <option value="rotring">Rotring</option>
                <option value="2B">2B Pencil</option>
                <option value="HB">HB Pencil</option>
                <option value="2H">2H Pencil</option>
                <option value="cpencil">Color Pencil</option>
                <option value="charcoal">Charcoal</option>
                <option value="hatch_brush">Hatch Brush</option>
                <option value="marker">Marker</option>
                <option value="marker2">Marker 2</option>
              </select>
            </label>
            <label
              >Hatch Line Width:
              <input
                type="number"
                x-model="hatchLineWidth"
                min="0.5"
                max="10"
                step="0.5"
                @change="updateChart()"
            /></label>
          </div>
        </div>
      </div>

      <!-- Typography Section -->
      <div class="collapsible-section">
        <div class="collapsible-header" @click="toggleSection('typography')">
          <span>Typography</span>
          <span class="arrow" :class="{ open: openSections.typography }"
            >►</span
          >
        </div>
        <div
          class="collapsible-content mobile-content-area"
          :class="{ 'mobile-active': activeTab === 'typography' }"
          x-show="!isMobile() ? openSections.typography : activeTab === 'typography'"
        >
          <label
            >Label Font Size:
            <input
              type="number"
              x-model="fontSize"
              min="8"
              max="64"
              @change="updateChart()"
          /></label>
          <label
            >Title Font Size:
            <input
              type="number"
              x-model="titleFontSize"
              min="12"
              max="72"
              @change="updateChart()"
          /></label>
        </div>
      </div>

      <!-- Canvas Dimensions Section -->
      <div class="collapsible-section">
        <div class="collapsible-header" @click="toggleSection('dimensions')">
          <span>Canvas</span>
          <span class="arrow" :class="{ open: openSections.dimensions }"
            >►</span
          >
        </div>
        <div
          class="collapsible-content mobile-content-area"
          :class="{ 'mobile-active': activeTab === 'dimensions' }"
          x-show="!isMobile() ? openSections.dimensions : activeTab === 'dimensions'"
        >
          <label
            >Canvas Width:
            <input type="number" x-model="canvasWidth" @change="updateChart()"
          /></label>
          <label
            >Canvas Height:
            <input type="number" x-model="canvasHeight" @change="updateChart()"
          /></label>
          <label
            >Padding:
            <input type="number" x-model="padding" @change="updateChart()"
          /></label>
        </div>
      </div>

      <div>
        <button @click="saveChart()">Copy chart to clipboard</button>
        <span
          class="button-message"
          x-show="copyStatus"
          x-text="copyStatus"
        ></span>

        <div x-show="chartType === 'histogram'">
          <h3>Histogram Data Input</h3>
          <p>Enter your data as a JSON array (e.g., [85, 92, 78, 105, 88]):</p>
          <textarea
            x-model="dataInput"
            class="data-input"
            placeholder="Enter data as JSON array..."
          ></textarea>
        </div>
        <div x-show="chartType === 'scatter'">
          <h3>Scatter Plot Data Input</h3>
          <p>
            Enter your data as an array of {x, y} objects or array of arrays:
          </p>
          <textarea
            x-model="dataInput"
            class="data-input"
            placeholder="[{x: 1, y: 2}, {x: 3, y: 4}] or [[{x: 1, y: 2}], [{x: 3, y: 4}]]"
          ></textarea>
        </div>
        <div x-show="chartType === 'boxplot'">
          <h3>Box Plot Data Input</h3>
          <p>
            Enter your data as an array of arrays (each inner array is a group):
          </p>
          <textarea
            x-model="dataInput"
            class="data-input"
            placeholder="[[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7]]"
          ></textarea>
        </div>
        <div x-show="chartType === 'line'">
          <h3>Line Plot Data Input</h3>
          <p>
            Enter Y values as an array or array of arrays. X values are
            optional:
          </p>
          <textarea
            x-model="dataInput"
            class="data-input"
            placeholder="[1, 2, 3, 4, 5] or [[1, 2, 3], [4, 5, 6]]"
          ></textarea>
        </div>
        <div x-show="chartType === 'barplot'">
          <h3>Bar Plot Data Input</h3>
          <p>
            Enter data as an array of numbers or array of {label, value}
            objects:
          </p>
          <textarea
            x-model="dataInput"
            class="data-input"
            placeholder="[10, 20, 30, 40] or [{label: 'A', value: 10}, {label: 'B', value: 20}]"
          ></textarea>
        </div>
      </div>
      <br />

      <div class="footer">
        Natural textures from
        <a href="https://github.com/acamposuribe/p5.brush">p5.brush</a>.
        <br />
        Tool and the charts by
        <a href="https://github.com/aapo/p5.databrush">Aapo Montin</a>
      </div>
    </div>
    <script src="C.js"></script>
    <script>
      function chartData() {
        return {
          chartType: "histogram",
          dataInput:
            "[85, 92, 78, 105, 88, 112, 95, 87, 103, 99, 76, 108, 91, 84, 97, 101, 89, 94, 106, 82]",
          parsedData: [
            85, 92, 78, 105, 88, 112, 95, 87, 103, 99, 76, 108, 91, 84, 97, 101,
            89, 94, 106, 82,
          ],
          isValidData: true,
          copyStatus: "",
          exportStatus: "",
          copyConfigStatus: "",
          loadClipboardStatus: "",
          loadStatus: "",
          palettePresetNames: Object.keys(C.palettePresets),
          stylePresetNames: Object.keys(C.stylePresets),
          stylePreset: "watercolor",
          // Load all config values from C.config
          canvasWidth: C.config.canvasWidth,
          canvasHeight: C.config.canvasHeight,
          padding: C.config.padding,
          numBins: 10,
          showDots: true,
          previousCanvasWidth: C.config.canvasWidth,
          previousCanvasHeight: C.config.canvasHeight,
          backgroundColor: C.config.backgroundColor,
          lineWidth: C.config.lineWidth,
          lineColor: C.config.lineColor,
          fontSize: C.config.fontSize,
          titleFontSize: C.config.titleFontSize,
          axisLabelColor: C.config.axisLabelColor,
          bleedMin: C.config.bleedMin,
          bleedMax: C.config.bleedMax,
          brushType: C.config.brushType,
          gridBrushType: C.config.gridBrushType,
          gridLineColor: C.config.gridLineColor,
          gridLineWidth: C.config.gridLineWidth,
          palettePreset: C.config.palettePreset,
          randomColors: C.config.randomColors,
          color1: C.config.color1,
          color2: C.config.color2,
          color3: C.config.color3,
          color4: C.config.color4,
          color5: C.config.color5,
          color6: C.config.color6,
          shuffleColors: false,
          shuffledPalette: [],
          fillType:
            C.config.fillType ||
            (C.config.useHatching ? "hatch" : "watercolor"),
          useHatching: C.config.useHatching,
          hatchDistance: C.config.hatchDistance,
          hatchAngle: C.config.hatchAngle,
          hatchRand: C.config.hatchRand,
          hatchContinuous: C.config.hatchContinuous,
          hatchGradient: C.config.hatchGradient,
          hatchBrushType: C.config.hatchBrushType,
          hatchLineWidth: C.config.hatchLineWidth,
          // Collapsible sections state
          openSections: {
            dimensions: false,
            chartOptions: false,
            style: false,
            typography: false,
            palette: false,
            fill: false,
          },
          // Active tab for mobile
          activeTab: "about",

          // Initialize component
          init() {
            // Apply watercolor preset on load
            if (this.stylePreset === "watercolor") {
              this.onStylePresetChange();
            }
          },

          // Check if on mobile device
          isMobile() {
            return window.innerWidth <= 800;
          },

          // Set active tab for mobile
          setActiveTab(tab) {
            this.activeTab = tab;
            // Scroll to top when changing tabs on mobile
            if (this.isMobile()) {
              window.scrollTo({ top: 0, behavior: "smooth" });

              // Scroll the active tab into view horizontally
              this.$nextTick(() => {
                const tabElement = this.$refs[`tab_${tab}`];
                const container = this.$refs.mobileTabsContainer;

                if (tabElement && container) {
                  // Calculate the position to scroll to center the tab
                  const tabRect = tabElement.getBoundingClientRect();
                  const containerRect = container.getBoundingClientRect();
                  const scrollLeft =
                    tabElement.offsetLeft -
                    containerRect.width / 2 +
                    tabRect.width / 2;

                  container.scrollTo({
                    left: scrollLeft,
                    behavior: "smooth",
                  });
                }
              });
            }
          },

          // Handle color input changes - only update on desktop
          handleColorInput() {
            if (!this.isMobile()) {
              this.onColorChange();
            }
          },

          toggleSection(section) {
            this.openSections[section] = !this.openSections[section];
          },

          getColorValue(index) {
            const colorKey = "color" + index;
            return this[colorKey];
          },

          setColorValue(index, value) {
            const colorKey = "color" + index;
            this[colorKey] = value;
            this.handleColorInput();
          },

          getScatterColorCount() {
            try {
              const parsed = JSON.parse(this.dataInput);
              if (
                Array.isArray(parsed[0]) &&
                parsed[0].length > 0 &&
                parsed[0][0].hasOwnProperty("x")
              ) {
                // Array of arrays - show min of groups or 6 colors (will loop if more groups)
                return Math.min(parsed.length, 6);
              }
              return 1; // Single array
            } catch (e) {
              return 1;
            }
          },

          getBoxPlotColorCount() {
            try {
              const parsed = JSON.parse(this.dataInput);
              if (Array.isArray(parsed) && Array.isArray(parsed[0])) {
                // Show min of boxes or 6 colors (will loop if more boxes)
                return Math.min(parsed.length, 6);
              }
              return 1;
            } catch (e) {
              return 1;
            }
          },

          getLineColorCount() {
            try {
              const parsed = JSON.parse(this.dataInput);
              if (Array.isArray(parsed[0])) {
                // Array of arrays - show min of lines or 6 colors (will loop if more lines)
                return Math.min(parsed.length, 6);
              }
              return 1; // Single array
            } catch (e) {
              return 1;
            }
          },

          getBarPlotColorCount() {
            try {
              const parsed = JSON.parse(this.dataInput);
              if (Array.isArray(parsed)) {
                // Show min of bars or 6 colors (will loop if more bars)
                return Math.min(parsed.length, 6);
              }
              return 1;
            } catch (e) {
              return 1;
            }
          },

          onStylePresetChange() {
            // Apply complete style configuration when preset changes
            if (
              this.stylePreset !== "custom" &&
              C.stylePresets[this.stylePreset]
            ) {
              const style = C.stylePresets[this.stylePreset];

              // Apply all style settings
              this.backgroundColor = style.backgroundColor;
              this.lineWidth = style.lineWidth;
              this.lineColor = style.lineColor;
              this.fontSize = style.fontSize;
              this.titleFontSize = style.titleFontSize;
              this.axisLabelColor = style.axisLabelColor;
              this.brushType = style.brushType;
              this.gridBrushType = style.gridBrushType;
              this.gridLineColor = style.gridLineColor;
              this.gridLineWidth = style.gridLineWidth;
              this.fillType = style.fillType;
              this.useHatching = style.useHatching;
              this.bleedMin = style.bleedMin;
              this.bleedMax = style.bleedMax;
              this.palettePreset = style.palettePreset;
              this.randomColors = style.randomColors;

              // Apply hatching settings if present
              if (style.hatchDistance !== undefined) {
                this.hatchDistance = style.hatchDistance;
              }
              if (style.hatchAngle !== undefined) {
                this.hatchAngle = style.hatchAngle;
              }
              if (style.hatchRand !== undefined) {
                this.hatchRand = style.hatchRand;
              }
              if (style.hatchContinuous !== undefined) {
                this.hatchContinuous = style.hatchContinuous;
              }
              if (style.hatchGradient !== undefined) {
                this.hatchGradient = style.hatchGradient;
              }
              if (style.hatchBrushType !== undefined) {
                this.hatchBrushType = style.hatchBrushType;
              }
              if (style.hatchLineWidth !== undefined) {
                this.hatchLineWidth = style.hatchLineWidth;
              }

              // Update palette colors (but don't trigger chart update from there)
              if (
                this.palettePreset !== "custom" &&
                C.palettePresets[this.palettePreset]
              ) {
                const colors = C.palettePresets[this.palettePreset];
                this.color1 = colors[0];
                this.color2 = colors[1];
                this.color3 = colors[2];
                this.color4 = colors[3];
                this.color5 = colors[4];
                this.color6 = colors[5];

                // If shuffle is on, create new shuffled palette
                if (this.shuffleColors) {
                  this.generateShuffledPalette();
                }
              }
            }

            this.updateChart();
          },

          onPalettePresetChange() {
            // Update colors when preset changes
            if (
              this.palettePreset !== "custom" &&
              C.palettePresets[this.palettePreset]
            ) {
              const colors = C.palettePresets[this.palettePreset];
              this.color1 = colors[0];
              this.color2 = colors[1];
              this.color3 = colors[2];
              this.color4 = colors[3];
              this.color5 = colors[4];
              this.color6 = colors[5];

              // If shuffle is on, create new shuffled palette
              if (this.shuffleColors) {
                this.generateShuffledPalette();
              }
            }

            this.updateChart();
          },

          onShuffleColorsChange() {
            if (this.shuffleColors) {
              this.generateShuffledPalette();
            }
            this.updateChart();
          },

          generateShuffledPalette() {
            // Create a shuffled version of the current palette
            const currentPalette = [
              this.color1,
              this.color2,
              this.color3,
              this.color4,
              this.color5,
              this.color6,
            ];

            // Fisher-Yates shuffle algorithm
            const shuffled = [...currentPalette];
            for (let i = shuffled.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            this.shuffledPalette = shuffled;
          },

          onColorChange() {
            // Switch to custom when any color is changed
            this.palettePreset = "custom";
            this.updateChart();
          },

          sampleNormal(m, s) {
            let u = 0,
              v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            const z =
              Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            return z * s + m;
          },

          sampleLogNormal(m, s) {
            const n = this.sampleNormal(m, s);
            return Math.exp(n / 10);
          },

          sampleBimodal(m, s) {
            const shift = Math.random() * 20 + 10;
            if (Math.random() > 0.5) return this.sampleNormal(m - shift, s);
            return this.sampleNormal(m + shift, s);
          },

          normalQuantile(p, mu, sigma) {
            var a1 = -3.969683028665376e1,
              a2 = 2.209460984245205e2,
              a3 = -2.759285104469687e2,
              a4 = 1.38357751867269e2,
              a5 = -3.066479806614716e1,
              a6 = 2.506628277459239;
            var b1 = -5.447609879822406e1,
              b2 = 1.615858368580409e2,
              b3 = -1.556989798598866e2,
              b4 = 6.680131188771972e1,
              b5 = -1.328068155288572e1;
            var c1 = -7.784894002430293e-3,
              c2 = -3.223964580411365e-1,
              c3 = -2.400758277161838,
              c4 = -2.549732539343734,
              c5 = 4.374664141464968,
              c6 = 2.938163982698783;
            var d1 = 7.784695709041462e-3,
              d2 = 3.224671290700398e-1,
              d3 = 2.445134137142996,
              d4 = 3.754408661907416;
            var plow = 0.02425;
            var phigh = 1 - plow;
            var q, r, x;
            if (p < plow) {
              q = Math.sqrt(-2 * Math.log(p));
              x = ((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6;
              x = x / ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
              x = -x;
            } else if (p <= phigh) {
              q = p - 0.5;
              r = q * q;
              x = (((((a1 * r + a2) * r + a3) * r + a4) * r + a5) * r + a6) * q;
              x = x / (((((b1 * r + b2) * r + b3) * r + b4) * r + b5) * r + 1);
            } else {
              q = Math.sqrt(-2 * Math.log(1 - p));
              x = ((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6;
              x = x / ((((d1 * q + d2) * q + d3) * q + d4) * q + 1);
            }
            return mu + sigma * x;
          },

          lognormalQuantile(p, mean, lnSigma) {
            var lnMu = Math.log(Math.max(1, mean)) - 0.5 * lnSigma * lnSigma;
            return Math.exp(this.normalQuantile(p, lnMu, lnSigma));
          },

          bimodalQuantile(p, mean, sigma, shift) {
            if (p < 0.5) return this.normalQuantile(p * 2, mean - shift, sigma);
            return this.normalQuantile((p - 0.5) * 2, mean + shift, sigma);
          },

          generateRandomData() {
            switch (this.chartType) {
              case "histogram":
                const histData = [];
                const numPoints = Math.floor(Math.random() * 60) + 60;
                const mean = Math.random() * 50 + 50;
                const sd = Math.random() * 10 + 2;

                const dists = ["normal", "lognormal", "bimodal"];
                const dist = dists[Math.floor(Math.random() * dists.length)];

                let lnMu = 0;
                let lnSigma = 0;
                if (dist === "lognormal") {
                  lnSigma = Math.random() * 0.6 + 0.2;
                  lnMu = Math.log(Math.max(1, mean)) - 0.5 * lnSigma * lnSigma;
                }

                let bimodalShift = 0;
                if (dist === "bimodal") {
                  bimodalShift = Math.random() * 12 + 8;
                }

                for (let i = 0; i < numPoints; i++) {
                  const p = (i + 1) / (numPoints + 1);
                  let val;
                  switch (dist) {
                    case "lognormal":
                      val = this.lognormalQuantile(p, mean, lnSigma);
                      break;
                    case "bimodal":
                      val = this.bimodalQuantile(p, mean, sd, bimodalShift);
                      break;
                    default:
                      val = this.normalQuantile(p, mean, sd);
                  }
                  if (!Number.isFinite(val) || Number.isNaN(val)) {
                    val = mean;
                  }
                  val = Math.round(val * 10) / 10;
                  histData.push(val);
                }
                this.dataInput = JSON.stringify(histData);
                break;

              case "scatter":
                const numClusters = Math.floor(Math.random() * 3) + 2;
                const scatterClusters = [];

                for (let c = 0; c < numClusters; c++) {
                  const cluster = [];
                  const clusterSize = Math.floor(Math.random() * 5) + 5;
                  const centerX = Math.random() * 15 + 5;
                  const centerY = Math.random() * 15 + 5;
                  const spreadX = Math.random() * 3 + 1;
                  const spreadY = Math.random() * 3 + 1;

                  for (let i = 0; i < clusterSize; i++) {
                    const x =
                      centerX +
                      (Math.random() + Math.random() + Math.random() - 1.5) *
                        spreadX;
                    const y =
                      centerY +
                      (Math.random() + Math.random() + Math.random() - 1.5) *
                        spreadY;
                    cluster.push({
                      x: Math.round(x * 100) / 100,
                      y: Math.round(y * 100) / 100,
                    });
                  }
                  scatterClusters.push(cluster);
                }
                this.dataInput = JSON.stringify(scatterClusters);
                break;

              case "boxplot":
                const numGroups = Math.floor(Math.random() * 10) + 2;
                const boxplotGroups = [];

                for (let g = 0; g < numGroups; g++) {
                  const group = [];
                  const groupSize = Math.floor(Math.random() * 40) + 50;
                  const groupMean = Math.random() * 3 + g;
                  const groupVariance = Math.random() * 4 + 2;

                  for (let i = 0; i < groupSize; i++) {
                    let sum = 0;
                    for (let j = 0; j < 6; j++) {
                      sum += Math.random();
                    }
                    let normalValue =
                      (sum / 6) * Math.sqrt(groupVariance) + groupMean;
                    group.push(Math.round(normalValue * 10) / 10);
                  }

                  boxplotGroups.push(group);
                }
                this.dataInput = JSON.stringify(boxplotGroups);
                break;

              case "line":
                const numLines = Math.floor(Math.random() * 3) + 2;
                const lineSeries = [];
                const numPointsPerLine = Math.floor(Math.random() * 15) + 10;

                for (let l = 0; l < numLines; l++) {
                  const line = [];
                  const baseValue = Math.random() * 5 + 1;
                  const trend = (Math.random() - 0.5) * 0.5;
                  const noise = Math.random() * 2 + 0.5;

                  for (let i = 0; i < numPointsPerLine; i++) {
                    const trendValue = baseValue + trend * i;
                    const randomNoise = (Math.random() - 0.5) * noise;
                    const value = trendValue + randomNoise;
                    line.push(Math.round(value * 10) / 10);
                  }
                  lineSeries.push(line);
                }
                this.dataInput = JSON.stringify(lineSeries);
                break;

              case "barplot":
                const numBars = Math.floor(Math.random() * 8) + 4;
                const barData = [];
                const labels = [
                  "Alpha",
                  "Beta",
                  "Gamma",
                  "Delta",
                  "Epsilon",
                  "Zeta",
                  "Eta",
                  "Theta",
                  "Iota",
                  "Kappa",
                  "Lambda",
                  "Mu",
                ];

                for (let i = 0; i < numBars; i++) {
                  const value = Math.round((Math.random() * 80 + 20) * 10) / 10;
                  barData.push({
                    label: labels[i % labels.length],
                    value: value,
                  });
                }
                this.dataInput = JSON.stringify(barData);
                break;
            }

            // Update the chart with new random data
            this.updateChart();
          },

          randomizeAll() {
            const chartTypes = [
              "histogram",
              "scatter",
              "boxplot",
              "line",
              "barplot",
            ];
            this.chartType =
              chartTypes[Math.floor(Math.random() * chartTypes.length)];

            const presetKeys = Object.keys(C.palettePresets);
            this.palettePreset =
              presetKeys[Math.floor(Math.random() * presetKeys.length)];

            if (
              this.palettePreset !== "custom" &&
              C.palettePresets[this.palettePreset]
            ) {
              const colors = C.palettePresets[this.palettePreset];
              this.color1 = colors[0];
              this.color2 = colors[1];
              this.color3 = colors[2];
              this.color4 = colors[3];
              this.color5 = colors[4];
              this.color6 = colors[5];
            }

            this.randomColors = Math.random() > 0.5;

            const bgColors = [
              "#f5f5dc",
              "#faf0e6",
              "#fff8dc",
              "#ffefd5",
              "#e6e6fa",
              "#f0f8ff",
              "#ccd5ae",
              "#e9edc9",
              "#fefae0",
              "#faedcd",
              "#edede9",
              "#d6ccc2",
              "#f5ebe0",
              "#e3d5ca",
              "#d5bdaf",
            ];
            this.backgroundColor =
              bgColors[Math.floor(Math.random() * bgColors.length)];

            const brushTypes = [
              "pen",
              "rotring",
              "2B",
              "HB",
              "2H",
              "cpencil",
              "charcoal",
              "marker",
              "marker2",
            ];
            this.brushType =
              brushTypes[Math.floor(Math.random() * brushTypes.length)];
            this.gridBrushType =
              brushTypes[Math.floor(Math.random() * brushTypes.length)];

            this.lineWidth = Math.floor(Math.random() * 5) + 1;
            this.gridLineWidth = Math.floor(Math.random() * 5) + 1;

            const fillTypes = ["watercolor", "hatch", "none"];
            this.fillType =
              fillTypes[Math.floor(Math.random() * fillTypes.length)];
            this.useHatching = this.fillType === "hatch";

            if (this.useHatching) {
              this.hatchDistance = Math.floor(Math.random() * 15) + 5;
              this.hatchAngle = Math.floor(Math.random() * 36) * 5;
              this.hatchRand = Math.round(Math.random() * 20) / 20;
              this.hatchContinuous = Math.random() > 0.5;
              this.hatchGradient = Math.round(Math.random() * 20) / 20;
              this.hatchBrushType =
                brushTypes[Math.floor(Math.random() * brushTypes.length)];
              this.hatchLineWidth = Math.floor(Math.random() * 8) + 1;
            } else {
              this.bleedMin = Math.round(Math.random() * 50) / 1000;
              this.bleedMax = Math.round(Math.random() * 50 + 50) / 1000;
            }

            this.fontSize = Math.floor(Math.random() * 10) + 14;
            this.titleFontSize = Math.floor(Math.random() * 30) + 24;

            if (this.chartType === "histogram") {
              this.numBins = Math.floor(Math.random() * 15) + 5;
            } else if (this.chartType === "line") {
              this.showDots = Math.random() > 0.5;
            }

            switch (this.chartType) {
              case "histogram":
                const histData = [];
                const numPoints = Math.floor(Math.random() * 60) + 60;
                const mean = Math.random() * 50 + 50;
                const sd = Math.random() * 10 + 5;

                const dists = ["normal", "lognormal", "bimodal"];
                const dist = dists[Math.floor(Math.random() * dists.length)];

                let lnMu = 0;
                let lnSigma = 0;
                if (dist === "lognormal") {
                  lnSigma = Math.random() * 0.6 + 0.2;
                  lnMu = Math.log(Math.max(1, mean)) - 0.5 * lnSigma * lnSigma;
                }

                let bimodalShift = 0;
                if (dist === "bimodal") {
                  bimodalShift = Math.random() * 12 + 8;
                }

                for (let i = 0; i < numPoints; i++) {
                  const p = (i + 1) / (numPoints + 1);
                  let val;
                  switch (dist) {
                    case "lognormal":
                      val = this.lognormalQuantile(p, mean, lnSigma);
                      break;
                    case "bimodal":
                      val = this.bimodalQuantile(p, mean, sd, bimodalShift);
                      break;
                    default:
                      val = this.normalQuantile(p, mean, sd);
                  }
                  if (!Number.isFinite(val) || Number.isNaN(val)) {
                    val = mean;
                  }
                  val = Math.round(val * 10) / 10;
                  histData.push(val);
                }
                this.dataInput = JSON.stringify(histData);
                break;

              case "scatter":
                const numClusters = Math.floor(Math.random() * 3) + 2;
                const scatterClusters = [];

                for (let c = 0; c < numClusters; c++) {
                  const cluster = [];
                  const clusterSize = Math.floor(Math.random() * 5) + 5;
                  const centerX = Math.random() * 15 + 5;
                  const centerY = Math.random() * 15 + 5;
                  const spreadX = Math.random() * 3 + 1;
                  const spreadY = Math.random() * 3 + 1;

                  for (let i = 0; i < clusterSize; i++) {
                    const x =
                      centerX +
                      (Math.random() + Math.random() + Math.random() - 1.5) *
                        spreadX;
                    const y =
                      centerY +
                      (Math.random() + Math.random() + Math.random() - 1.5) *
                        spreadY;
                    cluster.push({
                      x: Math.round(x * 100) / 100,
                      y: Math.round(y * 100) / 100,
                    });
                  }
                  scatterClusters.push(cluster);
                }
                this.dataInput = JSON.stringify(scatterClusters);
                break;

              case "boxplot":
                const numGroups = Math.floor(Math.random() * 10) + 2;
                const boxplotGroups = [];

                for (let g = 0; g < numGroups; g++) {
                  const group = [];
                  const groupSize = Math.floor(Math.random() * 40) + 50;
                  const groupMean = Math.random() * 3 + g;
                  const groupVariance = Math.random() * 4 + 2;

                  for (let i = 0; i < groupSize; i++) {
                    let sum = 0;
                    for (let j = 0; j < 6; j++) {
                      sum += Math.random();
                    }
                    let normalValue =
                      (sum / 6) * Math.sqrt(groupVariance) + groupMean;
                    group.push(Math.round(normalValue * 10) / 10);
                  }

                  boxplotGroups.push(group);
                }
                this.dataInput = JSON.stringify(boxplotGroups);
                break;

              case "line":
                const numLines = Math.floor(Math.random() * 3) + 2;
                const lineSeries = [];
                const numPointsPerLine = Math.floor(Math.random() * 15) + 10;

                for (let l = 0; l < numLines; l++) {
                  const line = [];
                  const baseValue = Math.random() * 5 + 1;
                  const trend = (Math.random() - 0.5) * 0.5;
                  const noise = Math.random() * 2 + 0.5;

                  for (let i = 0; i < numPointsPerLine; i++) {
                    const trendValue = baseValue + trend * i;
                    const randomNoise = (Math.random() - 0.5) * noise;
                    const value = trendValue + randomNoise;
                    line.push(Math.round(value * 10) / 10);
                  }
                  lineSeries.push(line);
                }
                this.dataInput = JSON.stringify(lineSeries);
                break;

              case "barplot":
                const numBarsRand = Math.floor(Math.random() * 8) + 4;
                const barDataRand = [];
                const labelsRand = [
                  "Alpha",
                  "Beta",
                  "Gamma",
                  "Delta",
                  "Epsilon",
                  "Zeta",
                  "Eta",
                  "Theta",
                  "Iota",
                  "Kappa",
                  "Lambda",
                  "Mu",
                ];

                for (let i = 0; i < numBarsRand; i++) {
                  const value = Math.round((Math.random() * 80 + 20) * 10) / 10;
                  barDataRand.push({
                    label: labelsRand[i % labelsRand.length],
                    value: value,
                  });
                }
                this.dataInput = JSON.stringify(barDataRand);
                break;
            }

            this.updateChart();
          },

          onChartTypeChange() {
            // Update example data based on chart type
            switch (this.chartType) {
              case "histogram":
                this.dataInput =
                  "[85, 92, 78, 105, 88, 112, 95, 87, 103, 99, 76, 108, 91, 84, 97, 101, 89, 94, 106, 82]";
                break;
              case "scatter":
                this.dataInput =
                  '[{"x": 1, "y": 2}, {"x": 3, "y": 4.5}, {"x": 5, "y": 3}, {"x": 7, "y": 8}, {"x": 9, "y": 6}]';
                break;
              case "boxplot":
                this.dataInput =
                  "[[1, 2, 3, 4, 5, 6, 7], [2, 3, 4, 5, 6, 7, 8], [3, 4, 5, 6, 7, 8, 9]]";
                break;
              case "line":
                this.dataInput = "[1, 2, 4, 3, 5, 7, 6, 8, 9, 8]";
                break;
              case "barplot":
                this.dataInput =
                  '[{"label": "A", "value": 25}, {"label": "B", "value": 40}, {"label": "C", "value": 30}, {"label": "D", "value": 55}, {"label": "E", "value": 20}]';
                break;
            }
            this.updateChart();
          },

          renderChart() {
            push();
            setupRest();

            try {
              const parsed = JSON.parse(this.dataInput);

              switch (this.chartType) {
                case "histogram":
                  if (
                    Array.isArray(parsed) &&
                    parsed.every((x) => typeof x === "number")
                  ) {
                    drawHistogram(parsed, Number(this.numBins));
                  } else {
                    this.isValidData = false;
                    pop();
                    return;
                  }
                  break;

                case "scatter":
                  // Validate scatter plot data
                  const isValidScatter =
                    Array.isArray(parsed) &&
                    // Single array of points
                    ((parsed.length > 0 &&
                      parsed[0].hasOwnProperty("x") &&
                      parsed[0].hasOwnProperty("y")) ||
                      // Array of arrays of points
                      (Array.isArray(parsed[0]) &&
                        parsed[0].length > 0 &&
                        parsed[0][0].hasOwnProperty("x")));

                  if (isValidScatter) {
                    drawGrid(Array.isArray(parsed[0]) ? parsed[0] : parsed);
                    drawScatterPlot(parsed);
                  } else {
                    this.isValidData = false;
                    pop();
                    return;
                  }
                  break;

                case "boxplot":
                  // Validate box plot data (array of arrays)
                  const isValidBoxplot =
                    Array.isArray(parsed) &&
                    parsed.length > 0 &&
                    Array.isArray(parsed[0]) &&
                    parsed.every(
                      (arr) =>
                        Array.isArray(arr) &&
                        arr.every((x) => typeof x === "number")
                    );

                  if (isValidBoxplot) {
                    drawBoxPlot(parsed);
                  } else {
                    this.isValidData = false;
                    pop();
                    return;
                  }
                  break;

                case "line":
                  // Validate line plot data (array or array of arrays)
                  const isValidLine =
                    Array.isArray(parsed) &&
                    (parsed.every((x) => typeof x === "number") ||
                      (Array.isArray(parsed[0]) &&
                        parsed.every(
                          (arr) =>
                            Array.isArray(arr) &&
                            arr.every((x) => typeof x === "number")
                        )));

                  if (isValidLine) {
                    drawGrid(
                      Array.isArray(parsed[0])
                        ? parsed[0].map((val, idx) => ({ x: idx + 1, y: val }))
                        : parsed.map((val, idx) => ({ x: idx + 1, y: val }))
                    );
                    drawLinePlot(parsed, null, this.showDots);
                  } else {
                    this.isValidData = false;
                    pop();
                    return;
                  }
                  break;

                case "barplot":
                  // Validate bar plot data (array of numbers or array of {label, value} objects)
                  const isValidBarplot =
                    Array.isArray(parsed) &&
                    (parsed.every((x) => typeof x === "number") ||
                      (parsed.length > 0 &&
                        typeof parsed[0] === "object" &&
                        parsed[0].hasOwnProperty("value") &&
                        parsed.every((x) => typeof x.value === "number")));

                  if (isValidBarplot) {
                    drawBarPlot(parsed);
                  } else {
                    this.isValidData = false;
                    pop();
                    return;
                  }
                  break;
              }

              this.isValidData = true;
            } catch (e) {
              this.isValidData = false;
              console.error("Chart rendering error:", e);
              pop();
              return;
            }

            pop();
          },

          updateChart() {
            const newW = Number(this.canvasWidth);
            const newH = Number(this.canvasHeight);
            const newPad = Number(this.padding);

            // Generate new shuffle every time if shuffle is enabled
            if (this.shuffleColors) {
              this.generateShuffledPalette();
            }

            const sizeChanged =
              newW !== this.previousCanvasWidth ||
              newH !== this.previousCanvasHeight;

            if (sizeChanged) {
              this.previousCanvasWidth = newW;
              this.previousCanvasHeight = newH;

              C.setConfig({
                canvasWidth: newW,
                canvasHeight: newH,
                padding: newPad,
                previousCanvasWidth: this.previousCanvasWidth,
                previousCanvasHeight: this.previousCanvasHeight,
                backgroundColor: this.backgroundColor,
                lineWidth: Number(this.lineWidth),
                lineColor: this.lineColor,
                fontSize: Number(this.fontSize),
                titleFontSize: Number(this.titleFontSize),
                axisLabelColor: this.axisLabelColor,
                bleedMin: Number(this.bleedMin),
                bleedMax: Number(this.bleedMax),
                brushType: this.brushType,
                gridBrushType: this.gridBrushType,
                gridLineColor: this.gridLineColor,
                gridLineWidth: Number(this.gridLineWidth),
                useHatching: this.useHatching,
                hatchDistance: Number(this.hatchDistance),
                hatchAngle: Number(this.hatchAngle),
                hatchRand: Number(this.hatchRand),
                hatchContinuous: this.hatchContinuous,
                hatchGradient: Number(this.hatchGradient),
                hatchBrushType: this.hatchBrushType,
                hatchLineWidth: Number(this.hatchLineWidth),
              });

              return;
            }

            C.setConfig({
              canvasWidth: newW,
              canvasHeight: newH,
              padding: newPad,
              previousCanvasWidth: this.previousCanvasWidth,
              previousCanvasHeight: this.previousCanvasHeight,
              backgroundColor: this.backgroundColor,
              lineWidth: Number(this.lineWidth),
              lineColor: this.lineColor,
              fontSize: Number(this.fontSize),
              titleFontSize: Number(this.titleFontSize),
              axisLabelColor: this.axisLabelColor,
              bleedMin: Number(this.bleedMin),
              bleedMax: Number(this.bleedMax),
              brushType: this.brushType,
              gridBrushType: this.gridBrushType,
              gridLineColor: this.gridLineColor,
              gridLineWidth: Number(this.gridLineWidth),
              palettePreset: this.palettePreset,
              randomColors: this.randomColors,
              shuffleColors: this.shuffleColors,
              shuffledPalette: this.shuffledPalette,
              color1: this.color1,
              color2: this.color2,
              color3: this.color3,
              color4: this.color4,
              color5: this.color5,
              color6: this.color6,
              palettePreset: this.palettePreset,
              randomColors: this.randomColors,
              shuffleColors: this.shuffleColors,
              shuffledPalette: this.shuffledPalette,
              color1: this.color1,
              color2: this.color2,
              color3: this.color3,
              color4: this.color4,
              color5: this.color5,
              color6: this.color6,
              fillType: this.fillType,
              useHatching: this.useHatching,
              hatchDistance: Number(this.hatchDistance),
              hatchAngle: Number(this.hatchAngle),
              hatchRand: Number(this.hatchRand),
              hatchContinuous: this.hatchContinuous,
              hatchGradient: Number(this.hatchGradient),
              hatchBrushType: this.hatchBrushType,
              hatchLineWidth: Number(this.hatchLineWidth),
            });
            this.renderChart();
          },

          async saveChart() {
            try {
              this.copyStatus = "Copying...";
              const canvas = document.getElementById("mainCanvas");
              if (!canvas) {
                this.copyStatus = "Canvas not found";
                setTimeout(() => (this.copyStatus = ""), 2000);
                return;
              }

              // Check if Clipboard API is available
              if (navigator.clipboard && navigator.clipboard.write) {
                try {
                  // Create a promise-based blob to maintain user activation
                  const blobPromise = new Promise((resolve) => {
                    canvas.toBlob(resolve, "image/png");
                  });

                  // Write to clipboard immediately while user activation is still active
                  await navigator.clipboard.write([
                    new ClipboardItem({ "image/png": blobPromise }),
                  ]);

                  this.copyStatus = "Copied to clipboard!";
                  setTimeout(() => (this.copyStatus = ""), 2000);
                } catch (err) {
                  console.error("Failed to copy to clipboard:", err);
                  // Fallback to download on mobile if clipboard fails
                  canvas.toBlob((blob) => {
                    this.downloadChart(blob);
                  });
                }
              } else {
                // Fallback for browsers that don't support clipboard API
                canvas.toBlob((blob) => {
                  this.downloadChart(blob);
                });
              }
            } catch (err) {
              console.error("Error copying chart:", err);
              this.copyStatus = "Failed to copy";
              setTimeout(() => (this.copyStatus = ""), 2000);
            }
          },

          downloadChart(blob) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            const timestamp = new Date()
              .toISOString()
              .replace(/[:.]/g, "-")
              .slice(0, -5);
            link.href = url;
            link.download = `p5-databrush-${timestamp}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            this.copyStatus = "Downloaded!";
            setTimeout(() => (this.copyStatus = ""), 2000);
          },

          exportConfig() {
            try {
              const configToExport = {
                // Chart settings
                chartType: this.chartType,
                numBins: this.numBins,
                showDots: this.showDots,

                // Canvas dimensions
                canvasWidth: this.canvasWidth,
                canvasHeight: this.canvasHeight,
                padding: this.padding,

                // Style preset
                stylePreset: this.stylePreset,

                // Style settings
                backgroundColor: this.backgroundColor,
                lineWidth: this.lineWidth,
                lineColor: this.lineColor,
                brushType: this.brushType,
                gridBrushType: this.gridBrushType,
                gridLineColor: this.gridLineColor,
                gridLineWidth: this.gridLineWidth,

                // Palette and colors
                palettePreset: this.palettePreset,
                randomColors: this.randomColors,
                color1: this.color1,
                color2: this.color2,
                color3: this.color3,
                color4: this.color4,
                color5: this.color5,
                color6: this.color6,

                // Fill settings
                fillType: this.fillType,
                useHatching: this.useHatching,
                bleedMin: this.bleedMin,
                bleedMax: this.bleedMax,
                hatchDistance: this.hatchDistance,
                hatchAngle: this.hatchAngle,
                hatchRand: this.hatchRand,
                hatchContinuous: this.hatchContinuous,
                hatchGradient: this.hatchGradient,
                hatchBrushType: this.hatchBrushType,
                hatchLineWidth: this.hatchLineWidth,

                // Typography
                fontSize: this.fontSize,
                titleFontSize: this.titleFontSize,
                axisLabelColor: this.axisLabelColor,

                // Data
                dataInput: this.dataInput,
              };

              const jsonString = JSON.stringify(configToExport, null, 2);
              const blob = new Blob([jsonString], { type: "application/json" });
              const url = URL.createObjectURL(blob);
              const link = document.createElement("a");
              const timestamp = new Date()
                .toISOString()
                .replace(/[:.]/g, "-")
                .slice(0, -5);
              link.href = url;
              link.download = `p5-databrush-config-${timestamp}.json`;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              URL.revokeObjectURL(url);

              this.exportStatus = "Config exported!";
              setTimeout(() => (this.exportStatus = ""), 2000);
            } catch (err) {
              console.error("Error exporting config:", err);
              this.exportStatus = "Export failed";
              setTimeout(() => (this.exportStatus = ""), 2000);
            }
          },

          async copyConfigToClipboard() {
            try {
              const configToExport = {
                // Chart settings
                chartType: this.chartType,
                numBins: this.numBins,
                showDots: this.showDots,

                // Canvas dimensions
                canvasWidth: this.canvasWidth,
                canvasHeight: this.canvasHeight,
                padding: this.padding,

                // Style preset
                stylePreset: this.stylePreset,

                // Style settings
                backgroundColor: this.backgroundColor,
                lineWidth: this.lineWidth,
                lineColor: this.lineColor,
                brushType: this.brushType,
                gridBrushType: this.gridBrushType,
                gridLineColor: this.gridLineColor,
                gridLineWidth: this.gridLineWidth,

                // Palette and colors
                palettePreset: this.palettePreset,
                randomColors: this.randomColors,
                color1: this.color1,
                color2: this.color2,
                color3: this.color3,
                color4: this.color4,
                color5: this.color5,
                color6: this.color6,

                // Fill settings
                fillType: this.fillType,
                useHatching: this.useHatching,
                bleedMin: this.bleedMin,
                bleedMax: this.bleedMax,
                hatchDistance: this.hatchDistance,
                hatchAngle: this.hatchAngle,
                hatchRand: this.hatchRand,
                hatchContinuous: this.hatchContinuous,
                hatchGradient: this.hatchGradient,
                hatchBrushType: this.hatchBrushType,
                hatchLineWidth: this.hatchLineWidth,

                // Typography
                fontSize: this.fontSize,
                titleFontSize: this.titleFontSize,
                axisLabelColor: this.axisLabelColor,

                // Data
                dataInput: this.dataInput,
              };

              const jsonString = JSON.stringify(configToExport, null, 2);

              if (navigator.clipboard && navigator.clipboard.writeText) {
                await navigator.clipboard.writeText(jsonString);
                this.copyConfigStatus = "Copied to clipboard!";
              } else {
                // Fallback for browsers that don't support clipboard API
                const textArea = document.createElement("textarea");
                textArea.value = jsonString;
                textArea.style.position = "fixed";
                textArea.style.left = "-999999px";
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand("copy");
                document.body.removeChild(textArea);
                this.copyConfigStatus = "Copied to clipboard!";
              }

              setTimeout(() => (this.copyConfigStatus = ""), 2000);
            } catch (err) {
              console.error("Error copying config:", err);
              this.copyConfigStatus = "Copy failed";
              setTimeout(() => (this.copyConfigStatus = ""), 2000);
            }
          },

          async loadConfigFromClipboard() {
            try {
              let jsonString = "";

              if (navigator.clipboard && navigator.clipboard.readText) {
                jsonString = await navigator.clipboard.readText();
              } else {
                // Fallback: prompt user to paste (less ideal but works)
                jsonString = prompt("Paste your config JSON here:");
                if (!jsonString) {
                  this.loadClipboardStatus = "Cancelled";
                  setTimeout(() => (this.loadClipboardStatus = ""), 2000);
                  return;
                }
              }

              const loadedConfig = JSON.parse(jsonString);

              // Apply all loaded config values
              if (loadedConfig.chartType !== undefined)
                this.chartType = loadedConfig.chartType;
              if (loadedConfig.numBins !== undefined)
                this.numBins = loadedConfig.numBins;
              if (loadedConfig.showDots !== undefined)
                this.showDots = loadedConfig.showDots;

              if (loadedConfig.canvasWidth !== undefined)
                this.canvasWidth = loadedConfig.canvasWidth;
              if (loadedConfig.canvasHeight !== undefined)
                this.canvasHeight = loadedConfig.canvasHeight;
              if (loadedConfig.padding !== undefined)
                this.padding = loadedConfig.padding;

              if (loadedConfig.stylePreset !== undefined)
                this.stylePreset = loadedConfig.stylePreset;

              if (loadedConfig.backgroundColor !== undefined)
                this.backgroundColor = loadedConfig.backgroundColor;
              if (loadedConfig.lineWidth !== undefined)
                this.lineWidth = loadedConfig.lineWidth;
              if (loadedConfig.lineColor !== undefined)
                this.lineColor = loadedConfig.lineColor;
              if (loadedConfig.brushType !== undefined)
                this.brushType = loadedConfig.brushType;
              if (loadedConfig.gridBrushType !== undefined)
                this.gridBrushType = loadedConfig.gridBrushType;
              if (loadedConfig.gridLineColor !== undefined)
                this.gridLineColor = loadedConfig.gridLineColor;
              if (loadedConfig.gridLineWidth !== undefined)
                this.gridLineWidth = loadedConfig.gridLineWidth;

              if (loadedConfig.palettePreset !== undefined)
                this.palettePreset = loadedConfig.palettePreset;
              if (loadedConfig.randomColors !== undefined)
                this.randomColors = loadedConfig.randomColors;
              if (loadedConfig.color1 !== undefined)
                this.color1 = loadedConfig.color1;
              if (loadedConfig.color2 !== undefined)
                this.color2 = loadedConfig.color2;
              if (loadedConfig.color3 !== undefined)
                this.color3 = loadedConfig.color3;
              if (loadedConfig.color4 !== undefined)
                this.color4 = loadedConfig.color4;
              if (loadedConfig.color5 !== undefined)
                this.color5 = loadedConfig.color5;
              if (loadedConfig.color6 !== undefined)
                this.color6 = loadedConfig.color6;

              if (loadedConfig.fillType !== undefined)
                this.fillType = loadedConfig.fillType;
              if (loadedConfig.useHatching !== undefined)
                this.useHatching = loadedConfig.useHatching;
              if (loadedConfig.bleedMin !== undefined)
                this.bleedMin = loadedConfig.bleedMin;
              if (loadedConfig.bleedMax !== undefined)
                this.bleedMax = loadedConfig.bleedMax;
              if (loadedConfig.hatchDistance !== undefined)
                this.hatchDistance = loadedConfig.hatchDistance;
              if (loadedConfig.hatchAngle !== undefined)
                this.hatchAngle = loadedConfig.hatchAngle;
              if (loadedConfig.hatchRand !== undefined)
                this.hatchRand = loadedConfig.hatchRand;
              if (loadedConfig.hatchContinuous !== undefined)
                this.hatchContinuous = loadedConfig.hatchContinuous;
              if (loadedConfig.hatchGradient !== undefined)
                this.hatchGradient = loadedConfig.hatchGradient;
              if (loadedConfig.hatchBrushType !== undefined)
                this.hatchBrushType = loadedConfig.hatchBrushType;
              if (loadedConfig.hatchLineWidth !== undefined)
                this.hatchLineWidth = loadedConfig.hatchLineWidth;

              if (loadedConfig.fontSize !== undefined)
                this.fontSize = loadedConfig.fontSize;
              if (loadedConfig.titleFontSize !== undefined)
                this.titleFontSize = loadedConfig.titleFontSize;
              if (loadedConfig.axisLabelColor !== undefined)
                this.axisLabelColor = loadedConfig.axisLabelColor;

              if (loadedConfig.dataInput !== undefined)
                this.dataInput = loadedConfig.dataInput;

              // Update the chart with loaded config
              this.updateChart();

              this.loadClipboardStatus = "Config loaded!";
              setTimeout(() => (this.loadClipboardStatus = ""), 2000);
            } catch (err) {
              console.error("Error loading config from clipboard:", err);
              this.loadClipboardStatus = "Load failed - invalid JSON";
              setTimeout(() => (this.loadClipboardStatus = ""), 3000);
            }
          },

          async loadConfig(event) {
            try {
              const file = event.target.files[0];
              if (!file) return;

              const text = await file.text();
              const loadedConfig = JSON.parse(text);

              // Apply all loaded config values
              if (loadedConfig.chartType !== undefined)
                this.chartType = loadedConfig.chartType;
              if (loadedConfig.numBins !== undefined)
                this.numBins = loadedConfig.numBins;
              if (loadedConfig.showDots !== undefined)
                this.showDots = loadedConfig.showDots;

              if (loadedConfig.canvasWidth !== undefined)
                this.canvasWidth = loadedConfig.canvasWidth;
              if (loadedConfig.canvasHeight !== undefined)
                this.canvasHeight = loadedConfig.canvasHeight;
              if (loadedConfig.stylePreset !== undefined)
                this.stylePreset = loadedConfig.stylePreset;
              if (loadedConfig.padding !== undefined)
                this.padding = loadedConfig.padding;

              if (loadedConfig.backgroundColor !== undefined)
                this.backgroundColor = loadedConfig.backgroundColor;
              if (loadedConfig.lineWidth !== undefined)
                this.lineWidth = loadedConfig.lineWidth;
              if (loadedConfig.lineColor !== undefined)
                this.lineColor = loadedConfig.lineColor;
              if (loadedConfig.brushType !== undefined)
                this.brushType = loadedConfig.brushType;
              if (loadedConfig.gridBrushType !== undefined)
                this.gridBrushType = loadedConfig.gridBrushType;
              if (loadedConfig.gridLineColor !== undefined)
                this.gridLineColor = loadedConfig.gridLineColor;
              if (loadedConfig.gridLineWidth !== undefined)
                this.gridLineWidth = loadedConfig.gridLineWidth;

              if (loadedConfig.palettePreset !== undefined)
                this.palettePreset = loadedConfig.palettePreset;
              if (loadedConfig.randomColors !== undefined)
                this.randomColors = loadedConfig.randomColors;
              if (loadedConfig.color1 !== undefined)
                this.color1 = loadedConfig.color1;
              if (loadedConfig.color2 !== undefined)
                this.color2 = loadedConfig.color2;
              if (loadedConfig.color3 !== undefined)
                this.color3 = loadedConfig.color3;
              if (loadedConfig.color4 !== undefined)
                this.color4 = loadedConfig.color4;
              if (loadedConfig.color5 !== undefined)
                this.color5 = loadedConfig.color5;
              if (loadedConfig.color6 !== undefined)
                this.color6 = loadedConfig.color6;

              if (loadedConfig.fillType !== undefined)
                this.fillType = loadedConfig.fillType;
              if (loadedConfig.useHatching !== undefined)
                this.useHatching = loadedConfig.useHatching;
              if (loadedConfig.bleedMin !== undefined)
                this.bleedMin = loadedConfig.bleedMin;
              if (loadedConfig.bleedMax !== undefined)
                this.bleedMax = loadedConfig.bleedMax;
              if (loadedConfig.hatchDistance !== undefined)
                this.hatchDistance = loadedConfig.hatchDistance;
              if (loadedConfig.hatchAngle !== undefined)
                this.hatchAngle = loadedConfig.hatchAngle;
              if (loadedConfig.hatchRand !== undefined)
                this.hatchRand = loadedConfig.hatchRand;
              if (loadedConfig.hatchContinuous !== undefined)
                this.hatchContinuous = loadedConfig.hatchContinuous;
              if (loadedConfig.hatchGradient !== undefined)
                this.hatchGradient = loadedConfig.hatchGradient;
              if (loadedConfig.hatchBrushType !== undefined)
                this.hatchBrushType = loadedConfig.hatchBrushType;
              if (loadedConfig.hatchLineWidth !== undefined)
                this.hatchLineWidth = loadedConfig.hatchLineWidth;

              if (loadedConfig.fontSize !== undefined)
                this.fontSize = loadedConfig.fontSize;
              if (loadedConfig.titleFontSize !== undefined)
                this.titleFontSize = loadedConfig.titleFontSize;
              if (loadedConfig.axisLabelColor !== undefined)
                this.axisLabelColor = loadedConfig.axisLabelColor;

              if (loadedConfig.dataInput !== undefined)
                this.dataInput = loadedConfig.dataInput;

              // Update the chart with loaded config
              this.updateChart();

              this.loadStatus = "Config loaded!";
              setTimeout(() => (this.loadStatus = ""), 2000);

              // Reset file input
              event.target.value = "";
            } catch (err) {
              console.error("Error loading config:", err);
              this.loadStatus = "Load failed";
              setTimeout(() => (this.loadStatus = ""), 2000);
            }
          },
        };
      }

      function setup() {
        commonSetup();
        // Initial chart render
        const data = [
          85, 92, 78, 105, 88, 112, 95, 87, 103, 99, 76, 108, 91, 84, 97, 101,
          89, 94, 106, 82,
        ];
        drawHistogram(data, 10);
      }

      function draw() {}
    </script>
  </body>
</html>
