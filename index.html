<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>P5.js Histogram</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Josefin+Sans:ital,wght@0,100..700;1,100..700&display=swap"
      rel="stylesheet"
    />
    <script src="p5.js"></script>
    <script src="spectral.min.js"></script>
    <script src="p5.brush.js"></script>
    <script
      defer
      src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"
    ></script>
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        font-family: "IBM Plex Serif", sans-serif;
        font-size: 16px;
        margin: 0;
        padding: 0;
        display: flex;
        align-items: flex-start;
        justify-content: center;
        min-height: 100vh;
        overflow-x: hidden;
        background-color: #fffefb;
        position: relative;
      }

      .data-input {
        margin: 10px 0;
        font-family: monospace;
        width: 100%;
        height: 200px;
        background-color: #00000000;
      }

      input {
        width: 128px;
      }

      input[type="number"],
      input[type="text"] {
        margin-left: 10px;
        float: right;
        border-radius: 0;
        border: none;
        background-color: #ffffff00;
      }

      input[type="color"] {
        height: 24px;
        border-radius: 0;
        padding: 0;
        border: none;
        background: none;
        float: right;
      }

      .controls {
        width: 400px;
        flex-shrink: 0;
        position: relative;
        min-height: 100vh;
        padding-left: 20px;
        padding-right: 10px;
        overflow: hidden;
        z-index: 999;
      }

      .controls::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ffffff85;
        backdrop-filter: blur(100px);
        -webkit-backdrop-filter: blur(100px);
        -webkit-mask-image: linear-gradient(
          to bottom,
          rgba(0, 0, 0, 0) 0px,
          rgba(0, 0, 0, 1) 100px
        );
        mask-image: linear-gradient(
          to bottom,
          rgba(0, 0, 0, 0) 0px,
          rgba(0, 0, 0, 1) 100px
        );
        z-index: -1;
      }

      .collapsible-section {
        border-top: 1px solid #000000;
      }

      .collapsible-header {
        padding-top: 10px;
        padding-bottom: 10px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        user-select: none;
        font-weight: bold;
      }

      .collapsible-content {
        border-top: none;
        padding-bottom: 15px;
        padding-top: 10px;
      }

      .collapsible-content label {
        display: block;
        margin-bottom: 8px;
      }

      .arrow {
        transition: transform 0.3s;
      }

      .arrow.open {
        transform: rotate(90deg);
      }

      #chartContainer {
        flex: 1;
        flex-direction: column;
        max-width: fit-content;
        height: 100vh;
        border: 1px solid #ccc;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        margin: 0;
        padding: 0;
        position: sticky;
        top: 0;
      }

      #chartContainer canvas {
        max-width: 100%;
        max-height: 95vh;
        padding: 0;
        width: auto !important;
        height: auto !important;
        display: block;
        object-fit: contain;
      }

      /* Responsive layout for smaller screens */
      @media (max-width: 800px) {
        body {
          flex-direction: column;
          align-items: stretch;
        }

        #chartContainer {
          margin: 0;
          position: sticky;
          top: 0;
          height: auto;
          max-height: 70vh;
          border: none;
          z-index: 100;
        }

        #chartContainer canvas {
          max-height: 70vh;
        }

        .controls {
          margin: 0;
          width: 100%;
          max-width: 800px;
          order: 2;
          margin-bottom: 20px;
          padding-left: 10px;
          padding-right: 10px;
          min-height: auto;
          overflow: visible;
        }
      }

      input,
      textarea,
      .dropdown {
        font-size: 16px;
      }

      .footer {
        margin-top: 50px;
        padding: 10px 0px 10px 0px;
        font-size: 12px;
        color: #666;
        text-align: left;
      }

      .footer a {
        color: #666;
      }

      button {
        font-family: "IBM Plex Serif", sans-serif;
        background-color: #00000000;
        color: rgb(0, 0, 0);
        border: 2px solid #000000;
        padding: 10px 20px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        margin-top: 10px;
        cursor: pointer;
        border-radius: 5px;
      }

      .button-message {
        font-size: 12px;
        margin-left: 10px;
      }

      .dropdown {
        font-family: "IBM Plex Serif", sans-serif;
        width: 128px;
        margin-left: 10px;
        padding-left: 10px;
        float: right;
        height: 22px;
        border: 0;
        background-color: #ffffff00;
        color: #000;
        padding: 0;
      }

      /* Mobile tab navigation */
      .mobile-tabs {
        display: none;
      }

      .mobile-content-area {
        display: none;
      }

      .mobile-section-title {
        display: none;
      }

      @media (max-width: 800px) {
        body {
          padding-bottom: 60px;
          justify-content: flex-start;
        }

        .controls {
          padding-bottom: 80px;
          overflow-y: visible;
          min-height: auto;
          position: relative;
        }

        .controls::before {
          content: "";
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ffffff85;
          backdrop-filter: blur(100px);
          -webkit-backdrop-filter: blur(100px);
          -webkit-mask-image: linear-gradient(
            to bottom,
            rgba(0, 0, 0, 0) 0px,
            rgba(0, 0, 0, 1) 85px
          );
          mask-image: linear-gradient(
            to bottom,
            rgba(0, 0, 0, 0) 0px,
            rgba(0, 0, 0, 1) 85px
          );
          z-index: -1;
          pointer-events: none;
        }

        .controls > h1,
        .controls > p {
          display: none;
        }

        .mobile-content-area {
          display: block;
          min-height: auto;
        }

        .mobile-section-title,
        .mobile-databrush-title {
          display: block;
          font-size: 2em;
          font-weight: bold;
          margin-top: 0;
          margin-bottom: 20px;
        }

        .mobile-tabs {
          display: block;
          position: fixed;
          bottom: 0;
          left: 0;
          right: 0;
          overflow-x: auto;
          overflow-y: hidden;
          white-space: nowrap;
          -webkit-overflow-scrolling: touch;
          border-top: 1px solid #000000;
          background-color: #ffffffee;
          backdrop-filter: blur(20px);
          -webkit-backdrop-filter: blur(20px);
          z-index: 1000;
          scrollbar-width: none; /* Firefox */
          -ms-overflow-style: none; /* Edge */
        }

        .mobile-tabs::-webkit-scrollbar {
          display: none; /* Chrome, Safari, Opera */
        }

        .mobile-tab {
          display: inline-block;
          padding: 15px 20px;
          cursor: pointer;
          user-select: none;
          font-weight: normal;
          color: #666;
          transition: color 0.2s, border-top-color 0.2s;
          border-top: 2px solid transparent;
        }

        .mobile-tab.active {
          color: #000;
          border-top-color: #000;
          text-shadow: 0 0 0.5px #000, 0 0 0.5px #000;
        }

        .collapsible-section {
          border-top: none;
        }

        .collapsible-header {
          display: none;
        }

        .collapsible-content {
          display: none;
          border-top: none;
        }

        .collapsible-content.mobile-active {
          display: block !important;
        }
      }
    </style>
  </head>
  <body x-data="chartData()">
    <div id="chartContainer"></div>
    <div class="controls">
      <h1>*p5.databrush</h1>
      <p>
        Visualize your data on a watercolor canvas. Choose from histograms,
        scatter plots, box plots, and line plots. Customize the settings and use
        your own data, or try randomized plots with sample datasets and
        palettes.
      </p>

      <!-- Mobile content area -->
      <div class="mobile-content-area">
        <!-- About section (mobile only) -->
        <div
          class="collapsible-content"
          :class="{ 'mobile-active': activeTab === 'about' }"
          x-show="activeTab === 'about'"
        >
          <h1 class="mobile-databrush-title">*p5.databrush</h1>
          <p>
            Visualize your data on a watercolor canvas. Choose from histograms,
            scatter plots, box plots, and line plots. Customize the settings and
            use your own data, or try randomized plots with sample datasets and
            palettes.
          </p>
          <button @click="generateRandomData()">Generate random data</button>
          <br />
          <button @click="updateChart()" x-text="'Redraw chart'"></button>
          <span class="button-message" x-show="!isValidData"
            >Please enter valid JSON array</span
          >
        </div>
      </div>

      <!-- Mobile tab navigation -->
      <div class="mobile-tabs">
        <div
          class="mobile-tab"
          :class="{ active: activeTab === 'about' }"
          @click="setActiveTab('about')"
        >
          About
        </div>
        <div
          class="mobile-tab"
          :class="{ active: activeTab === 'chartOptions' }"
          @click="setActiveTab('chartOptions')"
        >
          Chart
        </div>
        <div
          class="mobile-tab"
          :class="{ active: activeTab === 'style' }"
          @click="setActiveTab('style')"
        >
          Style
        </div>
        <div
          class="mobile-tab"
          :class="{ active: activeTab === 'palette' }"
          @click="setActiveTab('palette')"
        >
          Palette & Colors
        </div>
        <div
          class="mobile-tab"
          :class="{ active: activeTab === 'fill' }"
          @click="setActiveTab('fill')"
        >
          Fill
        </div>
        <div
          class="mobile-tab"
          :class="{ active: activeTab === 'typography' }"
          @click="setActiveTab('typography')"
        >
          Typography
        </div>
        <div
          class="mobile-tab"
          :class="{ active: activeTab === 'dimensions' }"
          @click="setActiveTab('dimensions')"
        >
          Canvas
        </div>
      </div>

      <!-- Chart Section -->
      <div class="collapsible-section">
        <div class="collapsible-header" @click="toggleSection('chartOptions')">
          <span>Chart</span>
          <span class="arrow" :class="{ open: openSections.chartOptions }"
            >►</span
          >
        </div>
        <div
          class="collapsible-content mobile-content-area"
          :class="{ 'mobile-active': activeTab === 'chartOptions' }"
          x-show="!isMobile() ? openSections.chartOptions : activeTab === 'chartOptions'"
        >
          <h1 class="mobile-section-title">Chart</h1>
          <label>
            Chart Type:
            <select
              class="dropdown"
              x-model="chartType"
              @change="onChartTypeChange()"
            >
              <option value="histogram">Histogram</option>
              <option value="scatter">Scatter Plot</option>
              <option value="boxplot">Box Plot</option>
              <option value="line">Line Plot</option>
            </select>
          </label>
          <div x-show="chartType === 'histogram'">
            <label
              >Number of Bins:
              <input type="number" x-model="numBins" @change="updateChart()"
            /></label>
          </div>
          <div x-show="chartType === 'line'">
            <label>
              <input
                type="checkbox"
                x-model="showDots"
                @change="updateChart()"
                style="width: auto; margin-left: 0; float: none"
              />
              Show Dots
            </label>
          </div>
        </div>
      </div>

      <!-- Style Section -->
      <div class="collapsible-section">
        <div class="collapsible-header" @click="toggleSection('style')">
          <span>Style</span>
          <span class="arrow" :class="{ open: openSections.style }">►</span>
        </div>
        <div
          class="collapsible-content mobile-content-area"
          :class="{ 'mobile-active': activeTab === 'style' }"
          x-show="!isMobile() ? openSections.style : activeTab === 'style'"
        >
          <h1 class="mobile-section-title">Style</h1>
          <label
            >Background Color:
            <input
              type="color"
              x-model="backgroundColor"
              @change="updateChart()"
          /></label>
          <label
            >Axis Label Color:
            <input
              type="color"
              x-model="axisLabelColor"
              @change="updateChart()"
          /></label>
          <label>
            Brush Type:
            <select
              class="dropdown"
              x-model="brushType"
              @change="updateChart()"
            >
              <option value="pen">Pen</option>
              <option value="rotring">Rotring</option>
              <option value="2B">2B Pencil</option>
              <option value="HB">HB Pencil</option>
              <option value="2H">2H Pencil</option>
              <option value="cpencil">Color Pencil</option>
              <option value="charcoal">Charcoal</option>
              <option value="hatch_brush">Hatch Brush</option>
              <option value="marker">Marker</option>
              <option value="marker2">Marker 2</option>
            </select>
          </label>
          <label
            >Line Color:
            <input type="color" x-model="lineColor" @change="updateChart()"
          /></label>
          <label
            >Line Width:
            <input
              type="number"
              x-model="lineWidth"
              min="0.5"
              max="10"
              step="0.5"
              @change="updateChart()"
          /></label>
          <label>
            Grid Brush Type:
            <select
              class="dropdown"
              x-model="gridBrushType"
              @change="updateChart()"
            >
              <option value="pen">Pen</option>
              <option value="rotring">Rotring</option>
              <option value="2B">2B Pencil</option>
              <option value="HB">HB Pencil</option>
              <option value="2H">2H Pencil</option>
              <option value="cpencil">Color Pencil</option>
              <option value="charcoal">Charcoal</option>
              <option value="hatch_brush">Hatch Brush</option>
              <option value="marker">Marker</option>
              <option value="marker2">Marker 2</option>
            </select>
          </label>
          <label
            >Grid Line Color:
            <input type="color" x-model="gridLineColor" @change="updateChart()"
          /></label>
          <label
            >Grid Line Width:
            <input
              type="number"
              x-model="gridLineWidth"
              min="0.5"
              max="10"
              step="0.5"
              @change="updateChart()"
          /></label>
        </div>
      </div>

      <!-- Palette & Colors Section -->
      <div class="collapsible-section">
        <div class="collapsible-header" @click="toggleSection('palette')">
          <span>Palette & Colors</span>
          <span class="arrow" :class="{ open: openSections.palette }">►</span>
        </div>
        <div
          class="collapsible-content mobile-content-area"
          :class="{ 'mobile-active': activeTab === 'palette' }"
          x-show="!isMobile() ? openSections.palette : activeTab === 'palette'"
        >
          <h1 class="mobile-section-title">Palette & Colors</h1>
          <label>
            Palette Preset:
            <select
              class="dropdown"
              x-model="palettePreset"
              @change="onPalettePresetChange()"
            >
              <template
                x-for="presetName in palettePresetNames"
                :key="presetName"
              >
                <option :value="presetName" x-text="presetName"></option>
              </template>
              <option value="custom">Custom</option>
            </select>
          </label>
          <label>
            <input
              type="checkbox"
              x-model="randomColors"
              @change="updateChart()"
              style="width: auto; margin-left: 0; float: none"
            />
            Random Colors from Palette
          </label>
          <div x-show="!randomColors">
            <!-- Histogram: 1 color -->
            <template x-if="chartType === 'histogram'">
              <div>
                <label
                  >Color 1:
                  <input
                    type="color"
                    x-model="color1"
                    @input="handleColorInput()"
                    @change="onColorChange()"
                /></label>
              </div>
            </template>

            <!-- Scatter plot: dynamic based on data -->
            <template x-if="chartType === 'scatter'">
              <div>
                <template x-for="i in getScatterColorCount()" :key="i">
                  <label>
                    <span
                      x-text="'Color ' + i + ':'"
                      style="display: inline-block; width: 60px"
                    ></span>
                    <input
                      type="color"
                      :value="getColorValue(i)"
                      @input="setColorValue(i, $event.target.value)"
                      @change="onColorChange()"
                    />
                  </label>
                </template>
              </div>
            </template>

            <!-- Box plot: dynamic based on data -->
            <template x-if="chartType === 'boxplot'">
              <div>
                <template x-for="i in getBoxPlotColorCount()" :key="i">
                  <label>
                    <span
                      x-text="'Color ' + i + ':'"
                      style="display: inline-block; width: 60px"
                    ></span>
                    <input
                      type="color"
                      :value="getColorValue(i)"
                      @input="setColorValue(i, $event.target.value)"
                      @change="onColorChange()"
                    />
                  </label>
                </template>
              </div>
            </template>

            <!-- Line plot: dynamic based on data -->
            <template x-if="chartType === 'line'">
              <div>
                <template x-for="i in getLineColorCount()" :key="i">
                  <label>
                    <span
                      x-text="'Color ' + i + ':'"
                      style="display: inline-block; width: 60px"
                    ></span>
                    <input
                      type="color"
                      :value="getColorValue(i)"
                      @input="setColorValue(i, $event.target.value)"
                      @change="onColorChange()"
                    />
                  </label>
                </template>
              </div>
            </template>
          </div>
        </div>
      </div>

      <!-- Fill Section -->
      <div class="collapsible-section">
        <div class="collapsible-header" @click="toggleSection('fill')">
          <span>Fill</span>
          <span class="arrow" :class="{ open: openSections.fill }">►</span>
        </div>
        <div
          class="collapsible-content mobile-content-area"
          :class="{ 'mobile-active': activeTab === 'fill' }"
          x-show="!isMobile() ? openSections.fill : activeTab === 'fill'"
        >
          <h1 class="mobile-section-title">Fill</h1>
          <label>
            Fill Type:
            <select
              class="dropdown"
              x-model="fillType"
              @change="useHatching = (fillType === 'hatch'); updateChart()"
            >
              <option value="watercolor">Watercolor</option>
              <option value="hatch">Hatch</option>
              <option value="none">No Fill</option>
            </select>
          </label>

          <!-- Watercolor -->
          <div x-show="fillType === 'watercolor'">
            <label
              >Bleed Min:
              <input
                type="number"
                x-model="bleedMin"
                min="0"
                max="1"
                step="0.01"
                @change="updateChart()"
            /></label>
            <label
              >Bleed Max:
              <input
                type="number"
                x-model="bleedMax"
                min="0"
                max="1"
                step="0.01"
                @change="updateChart()"
            /></label>
          </div>

          <!-- Hatching -->
          <div x-show="fillType === 'hatch'">
            <label
              >Hatch Distance:
              <input
                type="number"
                x-model="hatchDistance"
                min="1"
                max="20"
                step="1"
                @change="updateChart()"
            /></label>
            <label
              >Hatch Angle:
              <input
                type="number"
                x-model="hatchAngle"
                min="0"
                max="180"
                step="5"
                @change="updateChart()"
            /></label>
            <label
              >Hatch Randomness:
              <input
                type="number"
                x-model="hatchRand"
                min="0"
                max="1"
                step="0.05"
                @change="updateChart()"
            /></label>
            <label
              >Hatch Gradient:
              <input
                type="number"
                x-model="hatchGradient"
                min="0"
                max="1"
                step="0.05"
                @change="updateChart()"
            /></label>
            <label>
              <input
                type="checkbox"
                x-model="hatchContinuous"
                @change="updateChart()"
                style="width: auto; margin-left: 0; float: none"
              />
              Continuous Hatching
            </label>
            <label>
              Hatch Brush Type:
              <select
                class="dropdown"
                x-model="hatchBrushType"
                @change="updateChart()"
              >
                <option value="pen">Pen</option>
                <option value="rotring">Rotring</option>
                <option value="2B">2B Pencil</option>
                <option value="HB">HB Pencil</option>
                <option value="2H">2H Pencil</option>
                <option value="cpencil">Color Pencil</option>
                <option value="charcoal">Charcoal</option>
                <option value="hatch_brush">Hatch Brush</option>
                <option value="marker">Marker</option>
                <option value="marker2">Marker 2</option>
              </select>
            </label>
            <label
              >Hatch Line Width:
              <input
                type="number"
                x-model="hatchLineWidth"
                min="0.5"
                max="10"
                step="0.5"
                @change="updateChart()"
            /></label>
          </div>
        </div>
      </div>

      <!-- Typography Section -->
      <div class="collapsible-section">
        <div class="collapsible-header" @click="toggleSection('typography')">
          <span>Typography</span>
          <span class="arrow" :class="{ open: openSections.typography }"
            >►</span
          >
        </div>
        <div
          class="collapsible-content mobile-content-area"
          :class="{ 'mobile-active': activeTab === 'typography' }"
          x-show="!isMobile() ? openSections.typography : activeTab === 'typography'"
        >
          <h1 class="mobile-section-title">Typography</h1>
          <label
            >Label Font Size:
            <input
              type="number"
              x-model="fontSize"
              min="8"
              max="24"
              @change="updateChart()"
          /></label>
          <label
            >Title Font Size:
            <input
              type="number"
              x-model="titleFontSize"
              min="12"
              max="72"
              @change="updateChart()"
          /></label>
        </div>
      </div>

      <!-- Canvas Dimensions Section -->
      <div class="collapsible-section">
        <div class="collapsible-header" @click="toggleSection('dimensions')">
          <span>Canvas</span>
          <span class="arrow" :class="{ open: openSections.dimensions }"
            >►</span
          >
        </div>
        <div
          class="collapsible-content mobile-content-area"
          :class="{ 'mobile-active': activeTab === 'dimensions' }"
          x-show="!isMobile() ? openSections.dimensions : activeTab === 'dimensions'"
        >
          <h1 class="mobile-section-title">Canvas</h1>
          <label
            >Canvas Width:
            <input type="number" x-model="canvasWidth" @change="updateChart()"
          /></label>
          <label
            >Canvas Height:
            <input type="number" x-model="canvasHeight" @change="updateChart()"
          /></label>
          <label
            >Padding:
            <input type="number" x-model="padding" @change="updateChart()"
          /></label>
        </div>
      </div>

      <div style="display: none">
        <br />
        <button @click="saveChart()">Copy chart to clipboard</button>
        <span
          class="button-message"
          x-show="copyStatus"
          x-text="copyStatus"
        ></span>
        <br />
        <button @click="generateRandomData()">Generate random data</button>
        <br />
        <button @click="updateChart()" x-text="'Redraw chart'"></button>
        <span class="button-message" x-show="!isValidData"
          >Please enter valid JSON array</span
        >
        <div x-show="chartType === 'histogram'">
          <h3>Histogram Data Input</h3>
          <p>Enter your data as a JSON array (e.g., [85, 92, 78, 105, 88]):</p>
          <textarea
            x-model="dataInput"
            class="data-input"
            placeholder="Enter data as JSON array..."
          ></textarea>
        </div>
        <div x-show="chartType === 'scatter'">
          <h3>Scatter Plot Data Input</h3>
          <p>
            Enter your data as an array of {x, y} objects or array of arrays:
          </p>
          <textarea
            x-model="dataInput"
            class="data-input"
            placeholder="[{x: 1, y: 2}, {x: 3, y: 4}] or [[{x: 1, y: 2}], [{x: 3, y: 4}]]"
          ></textarea>
        </div>
        <div x-show="chartType === 'boxplot'">
          <h3>Box Plot Data Input</h3>
          <p>
            Enter your data as an array of arrays (each inner array is a group):
          </p>
          <textarea
            x-model="dataInput"
            class="data-input"
            placeholder="[[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7]]"
          ></textarea>
        </div>
        <div x-show="chartType === 'line'">
          <h3>Line Plot Data Input</h3>
          <p>
            Enter Y values as an array or array of arrays. X values are
            optional:
          </p>
          <textarea
            x-model="dataInput"
            class="data-input"
            placeholder="[1, 2, 3, 4, 5] or [[1, 2, 3], [4, 5, 6]]"
          ></textarea>
        </div>
      </div>
      <br />

      <div class="footer">
        Natural textures from
        <a href="https://github.com/acamposuribe/p5.brush">p5.brush</a>.
        <br />
        Tool and the charts by
        <a href="https://github.com/aapo/p5.databrush">Aapo Montin</a>
      </div>
    </div>
    <script src="C.js"></script>
    <script>
      function chartData() {
        return {
          chartType: "histogram",
          dataInput:
            "[85, 92, 78, 105, 88, 112, 95, 87, 103, 99, 76, 108, 91, 84, 97, 101, 89, 94, 106, 82]",
          parsedData: [
            85, 92, 78, 105, 88, 112, 95, 87, 103, 99, 76, 108, 91, 84, 97, 101,
            89, 94, 106, 82,
          ],
          isValidData: true,
          copyStatus: "",
          palettePresetNames: Object.keys(C.palettePresets),
          // Load all config values from C.config
          canvasWidth: C.config.canvasWidth,
          canvasHeight: C.config.canvasHeight,
          padding: C.config.padding,
          numBins: 10,
          showDots: true,
          previousCanvasWidth: C.config.canvasWidth,
          previousCanvasHeight: C.config.canvasHeight,
          backgroundColor: C.config.backgroundColor,
          lineWidth: C.config.lineWidth,
          lineColor: C.config.lineColor,
          fontSize: C.config.fontSize,
          titleFontSize: C.config.titleFontSize,
          axisLabelColor: C.config.axisLabelColor,
          bleedMin: C.config.bleedMin,
          bleedMax: C.config.bleedMax,
          brushType: C.config.brushType,
          gridBrushType: C.config.gridBrushType,
          gridLineColor: C.config.gridLineColor,
          gridLineWidth: C.config.gridLineWidth,
          palettePreset: C.config.palettePreset,
          randomColors: C.config.randomColors,
          color1: C.config.color1,
          color2: C.config.color2,
          color3: C.config.color3,
          color4: C.config.color4,
          color5: C.config.color5,
          color6: C.config.color6,
          fillType:
            C.config.fillType ||
            (C.config.useHatching ? "hatch" : "watercolor"),
          useHatching: C.config.useHatching,
          hatchDistance: C.config.hatchDistance,
          hatchAngle: C.config.hatchAngle,
          hatchRand: C.config.hatchRand,
          hatchContinuous: C.config.hatchContinuous,
          hatchGradient: C.config.hatchGradient,
          hatchBrushType: C.config.hatchBrushType,
          hatchLineWidth: C.config.hatchLineWidth,
          // Collapsible sections state
          openSections: {
            dimensions: false,
            chartOptions: false,
            style: false,
            typography: false,
            palette: false,
            fill: false,
          },
          // Active tab for mobile
          activeTab: "about",

          // Check if on mobile device
          isMobile() {
            return window.innerWidth <= 800;
          },

          // Set active tab for mobile
          setActiveTab(tab) {
            this.activeTab = tab;
            // Scroll to top when changing tabs on mobile
            if (this.isMobile()) {
              window.scrollTo({ top: 0, behavior: "smooth" });
            }
          },

          // Handle color input changes - only update on desktop
          handleColorInput() {
            if (!this.isMobile()) {
              this.onColorChange();
            }
          },

          toggleSection(section) {
            this.openSections[section] = !this.openSections[section];
          },

          getColorValue(index) {
            const colorKey = "color" + index;
            return this[colorKey];
          },

          setColorValue(index, value) {
            const colorKey = "color" + index;
            this[colorKey] = value;
            this.handleColorInput();
          },

          getScatterColorCount() {
            try {
              const parsed = JSON.parse(this.dataInput);
              if (
                Array.isArray(parsed[0]) &&
                parsed[0].length > 0 &&
                parsed[0][0].hasOwnProperty("x")
              ) {
                // Array of arrays - show min of groups or 6 colors (will loop if more groups)
                return Math.min(parsed.length, 6);
              }
              return 1; // Single array
            } catch (e) {
              return 1;
            }
          },

          getBoxPlotColorCount() {
            try {
              const parsed = JSON.parse(this.dataInput);
              if (Array.isArray(parsed) && Array.isArray(parsed[0])) {
                // Show min of boxes or 6 colors (will loop if more boxes)
                return Math.min(parsed.length, 6);
              }
              return 1;
            } catch (e) {
              return 1;
            }
          },

          getLineColorCount() {
            try {
              const parsed = JSON.parse(this.dataInput);
              if (Array.isArray(parsed[0])) {
                // Array of arrays - show min of lines or 6 colors (will loop if more lines)
                return Math.min(parsed.length, 6);
              }
              return 1; // Single array
            } catch (e) {
              return 1;
            }
          },

          onPalettePresetChange() {
            // Update colors when preset changes
            if (
              this.palettePreset !== "custom" &&
              C.palettePresets[this.palettePreset]
            ) {
              const colors = C.palettePresets[this.palettePreset];
              this.color1 = colors[0];
              this.color2 = colors[1];
              this.color3 = colors[2];
              this.color4 = colors[3];
              this.color5 = colors[4];
              this.color6 = colors[5];
            }

            this.updateChart();
          },

          onColorChange() {
            // Switch to custom when any color is changed
            this.palettePreset = "custom";
            this.updateChart();
          },

          generateRandomData() {
            switch (this.chartType) {
              case "histogram":
                const histData = [];
                const numPoints = Math.floor(Math.random() * 50) + 30;
                const mean = Math.random() * 50 + 50;
                const variance = Math.random() * 400 + 100;

                for (let i = 0; i < numPoints; i++) {
                  let sum = 0;
                  for (let j = 0; j < 6; j++) {
                    sum += Math.random();
                  }
                  let normalValue = (sum / 6) * Math.sqrt(variance) + mean;
                  histData.push(Math.round(normalValue * 10) / 10);
                }
                this.dataInput = JSON.stringify(histData);
                break;

              case "scatter":
                const numClusters = Math.floor(Math.random() * 3) + 2;
                const scatterClusters = [];

                for (let c = 0; c < numClusters; c++) {
                  const cluster = [];
                  const clusterSize = Math.floor(Math.random() * 5) + 5;
                  const centerX = Math.random() * 15 + 5;
                  const centerY = Math.random() * 15 + 5;
                  const spreadX = Math.random() * 3 + 1;
                  const spreadY = Math.random() * 3 + 1;

                  for (let i = 0; i < clusterSize; i++) {
                    const x =
                      centerX +
                      (Math.random() + Math.random() + Math.random() - 1.5) *
                        spreadX;
                    const y =
                      centerY +
                      (Math.random() + Math.random() + Math.random() - 1.5) *
                        spreadY;
                    cluster.push({
                      x: Math.round(x * 100) / 100,
                      y: Math.round(y * 100) / 100,
                    });
                  }
                  scatterClusters.push(cluster);
                }
                this.dataInput = JSON.stringify(scatterClusters);
                break;

              case "boxplot":
                const numGroups = Math.floor(Math.random() * 10) + 2;
                const boxplotGroups = [];

                for (let g = 0; g < numGroups; g++) {
                  const group = [];
                  const groupSize = Math.floor(Math.random() * 40) + 50;
                  const groupMean = Math.random() * 3 + g;
                  const groupVariance = Math.random() * 4 + 2;

                  for (let i = 0; i < groupSize; i++) {
                    let sum = 0;
                    for (let j = 0; j < 6; j++) {
                      sum += Math.random();
                    }
                    let normalValue =
                      (sum / 6) * Math.sqrt(groupVariance) + groupMean;
                    group.push(Math.round(normalValue * 10) / 10);
                  }

                  boxplotGroups.push(group);
                }
                this.dataInput = JSON.stringify(boxplotGroups);
                break;

              case "line":
                const numLines = Math.floor(Math.random() * 3) + 2;
                const lineSeries = [];
                const numPointsPerLine = Math.floor(Math.random() * 15) + 10;

                for (let l = 0; l < numLines; l++) {
                  const line = [];
                  const baseValue = Math.random() * 5 + 1;
                  const trend = (Math.random() - 0.5) * 0.5;
                  const noise = Math.random() * 2 + 0.5;

                  for (let i = 0; i < numPointsPerLine; i++) {
                    const trendValue = baseValue + trend * i;
                    const randomNoise = (Math.random() - 0.5) * noise;
                    const value = trendValue + randomNoise;
                    line.push(Math.round(value * 10) / 10);
                  }
                  lineSeries.push(line);
                }
                this.dataInput = JSON.stringify(lineSeries);
                break;
            }

            // Update the chart with new random data
            this.updateChart();
          },

          onChartTypeChange() {
            // Update example data based on chart type
            switch (this.chartType) {
              case "histogram":
                this.dataInput =
                  "[85, 92, 78, 105, 88, 112, 95, 87, 103, 99, 76, 108, 91, 84, 97, 101, 89, 94, 106, 82]";
                break;
              case "scatter":
                this.dataInput =
                  '[{"x": 1, "y": 2}, {"x": 3, "y": 4.5}, {"x": 5, "y": 3}, {"x": 7, "y": 8}, {"x": 9, "y": 6}]';
                break;
              case "boxplot":
                this.dataInput =
                  "[[1, 2, 3, 4, 5, 6, 7], [2, 3, 4, 5, 6, 7, 8], [3, 4, 5, 6, 7, 8, 9]]";
                break;
              case "line":
                this.dataInput = "[1, 2, 4, 3, 5, 7, 6, 8, 9, 8]";
                break;
            }
            this.updateChart();
          },

          renderChart() {
            setupRest();

            try {
              const parsed = JSON.parse(this.dataInput);

              switch (this.chartType) {
                case "histogram":
                  if (
                    Array.isArray(parsed) &&
                    parsed.every((x) => typeof x === "number")
                  ) {
                    drawHistogram(parsed, Number(this.numBins));
                  } else {
                    this.isValidData = false;
                    return;
                  }
                  break;

                case "scatter":
                  // Validate scatter plot data
                  const isValidScatter =
                    Array.isArray(parsed) &&
                    // Single array of points
                    ((parsed.length > 0 &&
                      parsed[0].hasOwnProperty("x") &&
                      parsed[0].hasOwnProperty("y")) ||
                      // Array of arrays of points
                      (Array.isArray(parsed[0]) &&
                        parsed[0].length > 0 &&
                        parsed[0][0].hasOwnProperty("x")));

                  if (isValidScatter) {
                    drawGrid(Array.isArray(parsed[0]) ? parsed[0] : parsed);
                    drawScatterPlot(parsed);
                  } else {
                    this.isValidData = false;
                    return;
                  }
                  break;

                case "boxplot":
                  // Validate box plot data (array of arrays)
                  const isValidBoxplot =
                    Array.isArray(parsed) &&
                    parsed.length > 0 &&
                    Array.isArray(parsed[0]) &&
                    parsed.every(
                      (arr) =>
                        Array.isArray(arr) &&
                        arr.every((x) => typeof x === "number")
                    );

                  if (isValidBoxplot) {
                    drawBoxPlot(parsed);
                  } else {
                    this.isValidData = false;
                    return;
                  }
                  break;

                case "line":
                  // Validate line plot data (array or array of arrays)
                  const isValidLine =
                    Array.isArray(parsed) &&
                    (parsed.every((x) => typeof x === "number") ||
                      (Array.isArray(parsed[0]) &&
                        parsed.every(
                          (arr) =>
                            Array.isArray(arr) &&
                            arr.every((x) => typeof x === "number")
                        )));

                  if (isValidLine) {
                    drawGrid(
                      Array.isArray(parsed[0])
                        ? parsed[0].map((val, idx) => ({ x: idx + 1, y: val }))
                        : parsed.map((val, idx) => ({ x: idx + 1, y: val }))
                    );
                    drawLinePlot(parsed, null, this.showDots);
                  } else {
                    this.isValidData = false;
                    return;
                  }
                  break;
              }

              this.isValidData = true;
            } catch (e) {
              this.isValidData = false;
              console.error("Chart rendering error:", e);
            }
          },

          updateChart() {
            const newW = Number(this.canvasWidth);
            const newH = Number(this.canvasHeight);
            const newPad = Number(this.padding);

            const sizeChanged =
              newW !== this.previousCanvasWidth ||
              newH !== this.previousCanvasHeight;

            if (sizeChanged) {
              this.previousCanvasWidth = newW;
              this.previousCanvasHeight = newH;

              C.setConfig({
                canvasWidth: newW,
                canvasHeight: newH,
                padding: newPad,
                previousCanvasWidth: this.previousCanvasWidth,
                previousCanvasHeight: this.previousCanvasHeight,
                backgroundColor: this.backgroundColor,
                lineWidth: Number(this.lineWidth),
                lineColor: this.lineColor,
                fontSize: Number(this.fontSize),
                titleFontSize: Number(this.titleFontSize),
                axisLabelColor: this.axisLabelColor,
                bleedMin: Number(this.bleedMin),
                bleedMax: Number(this.bleedMax),
                brushType: this.brushType,
                gridBrushType: this.gridBrushType,
                gridLineColor: this.gridLineColor,
                gridLineWidth: Number(this.gridLineWidth),
                useHatching: this.useHatching,
                hatchDistance: Number(this.hatchDistance),
                hatchAngle: Number(this.hatchAngle),
                hatchRand: Number(this.hatchRand),
                hatchContinuous: this.hatchContinuous,
                hatchGradient: Number(this.hatchGradient),
                hatchBrushType: this.hatchBrushType,
                hatchLineWidth: Number(this.hatchLineWidth),
              });

              return;
            }

            C.setConfig({
              canvasWidth: newW,
              canvasHeight: newH,
              padding: newPad,
              previousCanvasWidth: this.previousCanvasWidth,
              previousCanvasHeight: this.previousCanvasHeight,
              backgroundColor: this.backgroundColor,
              lineWidth: Number(this.lineWidth),
              lineColor: this.lineColor,
              fontSize: Number(this.fontSize),
              titleFontSize: Number(this.titleFontSize),
              axisLabelColor: this.axisLabelColor,
              bleedMin: Number(this.bleedMin),
              bleedMax: Number(this.bleedMax),
              brushType: this.brushType,
              gridBrushType: this.gridBrushType,
              gridLineColor: this.gridLineColor,
              gridLineWidth: Number(this.gridLineWidth),
              palettePreset: this.palettePreset,
              randomColors: this.randomColors,
              color1: this.color1,
              color2: this.color2,
              color3: this.color3,
              color4: this.color4,
              color5: this.color5,
              color6: this.color6,
              palettePreset: this.palettePreset,
              randomColors: this.randomColors,
              color1: this.color1,
              color2: this.color2,
              color3: this.color3,
              color4: this.color4,
              color5: this.color5,
              color6: this.color6,
              fillType: this.fillType,
              useHatching: this.useHatching,
              hatchDistance: Number(this.hatchDistance),
              hatchAngle: Number(this.hatchAngle),
              hatchRand: Number(this.hatchRand),
              hatchContinuous: this.hatchContinuous,
              hatchGradient: Number(this.hatchGradient),
              hatchBrushType: this.hatchBrushType,
              hatchLineWidth: Number(this.hatchLineWidth),
            });
            this.renderChart();
          },

          async saveChart() {
            try {
              this.copyStatus = "Copying...";
              const canvas = document.getElementById("mainCanvas");
              if (!canvas) {
                this.copyStatus = "Canvas not found";
                setTimeout(() => (this.copyStatus = ""), 2000);
                return;
              }

              // Check if Clipboard API is available
              if (navigator.clipboard && navigator.clipboard.write) {
                try {
                  // Create a promise-based blob to maintain user activation
                  const blobPromise = new Promise((resolve) => {
                    canvas.toBlob(resolve, "image/png");
                  });

                  // Write to clipboard immediately while user activation is still active
                  await navigator.clipboard.write([
                    new ClipboardItem({ "image/png": blobPromise }),
                  ]);

                  this.copyStatus = "Copied to clipboard!";
                  setTimeout(() => (this.copyStatus = ""), 2000);
                } catch (err) {
                  console.error("Failed to copy to clipboard:", err);
                  // Fallback to download on mobile if clipboard fails
                  canvas.toBlob((blob) => {
                    this.downloadChart(blob);
                  });
                }
              } else {
                // Fallback for browsers that don't support clipboard API
                canvas.toBlob((blob) => {
                  this.downloadChart(blob);
                });
              }
            } catch (err) {
              console.error("Error copying chart:", err);
              this.copyStatus = "Failed to copy";
              setTimeout(() => (this.copyStatus = ""), 2000);
            }
          },

          downloadChart(blob) {
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            const timestamp = new Date()
              .toISOString()
              .replace(/[:.]/g, "-")
              .slice(0, -5);
            link.href = url;
            link.download = `p5-databrush-${timestamp}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            this.copyStatus = "Downloaded!";
            setTimeout(() => (this.copyStatus = ""), 2000);
          },
        };
      }

      function setup() {
        commonSetup();
        // Initial chart render
        const data = [
          85, 92, 78, 105, 88, 112, 95, 87, 103, 99, 76, 108, 91, 84, 97, 101,
          89, 94, 106, 82,
        ];
        drawHistogram(data, 10);
      }

      function draw() {}
    </script>
  </body>
</html>
